/* Process a stream of stack samples into stack traces.
   Copyright (C) 2023 Red Hat, Inc.
   This file is part of elfutils.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <config.h>
#include <assert.h>
#include <argp.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>

#include <system.h>

/* TODO: Make optional through configury.  The #ifdefs are included
   now so we don't miss any code that needs to be controlled with this
   option. */
#define HAVE_SYSPROF_4_HEADERS
#ifdef HAVE_SYSPROF_4_HEADERS
#include <sysprof-4/sysprof-capture-types.h>
#endif

static char *input_path = NULL;
static int input_fd = -1;
static char *output_path = NULL;
static int output_fd = -1;

static size_t passthru_buffer_len = 0;
static char *passthru_buffer = NULL;

#define MODE_OPTS "none/passthru"
#define MODE_NONE 0x0
#define MODE_PASSTHRU 0x1
#define MODE_NAIVE 0x2
#define MODE_CACHING 0x3
static int processing_mode;

#define FORMAT_OPTS "sysprof"
#define FORMAT_PERF 0x1
#define FORMAT_SYSPROF 0x2
static int input_format;

/* Program exit codes.  All samples processed without any errors is
   GOOD.  Some non-fatal errors during processing is an ERROR.  A
   fatal error or no samples processed at all is BAD.  A command line
   USAGE exit is generated by argp_error. */
#define EXIT_OK     0
#define EXIT_ERROR  1
#define EXIT_BAD    2
#define EXIT_USAGE 64

static error_t
parse_opt (int key, char *arg __attribute__ ((unused)),
	   struct argp_state *state)
{
  switch (key)
    {
    case 'i':
      input_path = arg;
      break;

    case 'o':
      output_path = arg;
      break;

    case 'm':
      if (strcmp (arg, "none") == 0)
	{
	  processing_mode = MODE_NONE;
	}
      else if (strcmp (arg, "passthru") == 0)
	{
	  processing_mode = MODE_PASSTHRU;
	}
      else
	{
	  argp_error (state, N_("Unsupported -m '%s', should be " MODE_OPTS "."), arg); 
	}
      break;

    case 'f':
      if (strcmp (arg, "sysprof") == 0)
	{
	  input_format = FORMAT_SYSPROF;
	}
      else
	{
	  argp_error (state, N_("Unsupported -f '%s', should be " FORMAT_OPTS "."), arg); 
	}
      break;

    case ARGP_KEY_END:
      if (input_path == NULL)
	input_path = "-"; /* default to stdin */

      if (output_path == NULL)
	output_path = "-"; /* default to stdout */

      if (processing_mode == 0)
	processing_mode = MODE_PASSTHRU;

      if (input_format == 0)
	input_format = FORMAT_SYSPROF;
      break;

    default:
      return ARGP_ERR_UNKNOWN;
    }
  return 0;
}

int
main (int argc, char **argv)
{
  /* Set locale. */
  (void) setlocale (LC_ALL, "");

  const struct argp_option options[] =
    {
      { NULL, 0, NULL, 0, N_("Input and output selection options:"), 0 },
      { "input", 'i', "PATH", 0,
	N_("File or FIFO to read stack samples from"), 0 },
      /* TODO: Should also support taking an FD for fork/exec pipes. */
      { "output", 'o', "PATH", 0,
	N_("File or FIFO to send stack traces to"), 0 },

      { NULL, 0, NULL, 0, N_("Processing options:"), 0 },
      { "mode", 'm', MODE_OPTS, 0,
	N_("Processing mode, default 'passthru'"), 0 },
      /* TODO: Should also support 'naive', 'caching'. */
      /* TODO: Add an option to control stack-stitching. */
      { "format", 'f', FORMAT_OPTS, 0,
	N_("Input data format, default 'sysprof'"), 0 },
      /* TODO: Add an option to control output data format separately,
	 shift to I/O selection section. */
      { NULL, 0, NULL, 0, NULL, 0 }
    };

  const struct argp argp =
    {
      .options = options,
      .parser = parse_opt,
      .doc = N_("Process a stream of stack samples into stack traces.\n\
\n\
Utility is a work-in-progress, see README.eu-stacktrace in the source branch.")
    };

  argp_parse(&argp, argc, argv, 0, NULL, NULL);

#ifndef HAVE_SYSPROF_4_HEADERS
  /* TODO: Should hide corresponding command line options when this is the case. */
  error (EXIT_BAD, 0, N_("Sysprof support is not available in this version."));
#endif

  /* TODO Also handle common expansions e.g. ~/foo instead of /home/user/foo. */
  if (strcmp (input_path, "-") == 0)
    input_fd = STDIN_FILENO;
  else
    input_fd = open (input_path, O_RDONLY);
  if (input_fd < 0)
    error (EXIT_BAD, errno, N_("Cannot open input file or FIFO '%s'"), input_path);
  if (strcmp (output_path, "-") == 0)
    output_fd = STDOUT_FILENO;
  else
    output_fd = open (output_path, O_WRONLY);
  if (output_fd < 0)
    error (EXIT_BAD, errno, N_("Cannot open output file or FIFO '%s'"), output_path);

  /* TODO For now, just pipe data through with no packet separation. Just a quick 'cat' hack. */
  passthru_buffer_len = 8192;
  passthru_buffer = (char *)malloc (passthru_buffer_len);
  for (;;)
    {
      ssize_t n_read;
      n_read = read (input_fd, passthru_buffer, passthru_buffer_len);
      if (n_read < 0)
	error (EXIT_BAD, errno, N_("Read error from file or FIFO '%s'"), input_path);
      if (n_read == 0)
	break;
      if (n_read != write (output_fd, passthru_buffer, n_read))
	error (EXIT_BAD, errno, N_("Write error to file or FIFO '%s'"), output_path);
    }
  free (passthru_buffer);
  /* TODO Also support mode none, which outputs nothing. */

  if (input_fd != -1)
    close (input_fd);
  if (output_fd != -1)
    close (output_fd);

  return EXIT_OK;
}
