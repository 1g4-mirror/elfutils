/* -*- C++ -*- interfaces for libdw.
   Copyright (C) 2009 Red Hat, Inc.
   This file is part of Red Hat elfutils.

   Red Hat elfutils is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by the
   Free Software Foundation; version 2 of the License.

   Red Hat elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with Red Hat elfutils; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.

   In addition, as a special exception, Red Hat, Inc. gives You the
   additional right to link the code of Red Hat elfutils with code licensed
   under any Open Source Initiative certified open source license
   (http://www.opensource.org/licenses/index.php) which requires the
   distribution of source code with any binary distribution and to
   distribute linked combinations of the two.  Non-GPL Code permitted under
   this exception must only link to the code of Red Hat elfutils through
   those well defined interfaces identified in the file named EXCEPTION
   found in the source code files (the "Approved Interfaces").  The files
   of Non-GPL Code may instantiate templates or use macros or inline
   functions from the Approved Interfaces without causing the resulting
   work to be covered by the GNU General Public License.  Only Red Hat,
   Inc. may make changes or additions to the list of Approved Interfaces.
   Red Hat's grant of this exception is conditioned upon your not adding
   any new exceptions.  If you wish to add a new Approved Interface or
   exception, please contact Red Hat.  You must obey the GNU General Public
   License in all respects for all of the Red Hat elfutils code and other
   code used in conjunction with Red Hat elfutils except the Non-GPL Code
   covered by this exception.  If you modify this file, you may extend this
   exception to your version of the file, but you are not obligated to do
   so.  If you do not wish to provide this exception without modification,
   you must delete this exception statement from your version and license
   this file solely under the GPL without exception.

   Red Hat elfutils is an included package of the Open Invention Network.
   An included package of the Open Invention Network is a package for which
   Open Invention Network licensees cross-license their patents.  No patent
   license is granted, either expressly or impliedly, by designation as an
   included package.  Should you wish to participate in the Open Invention
   Network licensing program, please visit www.openinventionnetwork.com
   <http://www.openinventionnetwork.com>.  */

#ifndef _ELFUTILS_DWARF
#define _ELFUTILS_DWARF	1

#include "libdw.h"
#include "dwarf.h"
#include <stdexcept>
#include <iterator>

#include <cstring>
#include <iostream>
#include <sstream>
#include <list>
#include <map>
#include <stack>
#include <algorithm>
#include <functional>

/* Abstractly, one DWARF object file consists of a few containers.
   (We omit .debug_frame for now.  It does not interact with the others.)

   1. list of compilation units		(.debug_info)
   2. map of PC ranges to CU		(.debug_aranges)
   3. map of global names to CU+DIE	(.debug_pubnames)
   4. map of type names to CU+DIE	(.debug_pubtypes)

   These maps refer to the CUs in .debug_info and optimize lookups
   compared to simple iteration.

   A compile_unit is a debug_info_entry.
   A debug_info_entry consists of a tag (int/enum), and two containers:
   children and attributes.  The attributes are an unordered map of name
   (int/enum) to attribute value (complex variant record).  Children are
   in an ordered list, each also a debug_info_entry.

   dwarf.compile_units ()		works like list<compile_unit>
	-> compile_unit : debug_info_entry
		.attributes ()		like unordered_map<int, attr_value>
		.children ()		works like list<debug_info_entry>
			-> debug_info_entry
				.attributes ()
				.children ()

  A compile_unit is not deeply special, it's just a debug_info_entry.
  It has its own class just for some convenience methods that only
  make sense for a compile_unit DIE.

  This is the "logical" view of the file, grafting and eliding parts of the
  raw information that are purely the structural elements of DWARF and not
  part of the abstract semantics.  In the file reader (elfutils::dwarf),
  these containers form a layer above the raw containers that expose the
  file data directly (as the libdw C interfaces do).

  dwarf.raw_compile_units ()		works like list<compile_unit>
	-> compile_unit : debug_info_entry
		.raw_attributes ()	like unordered_map<int, attr_value>
		.raw_children ()	works like list<debug_info_entry>
			-> debug_info_entry
				.raw_attributes ()
				.raw_children ()

  compile_units () elides DW_TAG_partial_unit members,
  raw_compile_units () includes them.

  attributes () elides DW_AT_sibling, raw_attributes () includes it.

  raw_children () reports DW_TAG_imported_unit as any other child.
  children () flattens imported units into the containing list.

  The == and != comparisons for dwarf and debug_info_entry objects compare
  their logical containers, not the raw containers.  The comparisons are
  defined via templates, so you can compare elfutils::dwarf with any other
  class that implements the same structure of containers with input iterators.

  The elfutils::dwarf class and its inner classes form a thin, read-only
  layer of virtual containers that ideally could inline away entirely to
  calls into the C libdw API and small amounts of stack storage.  The tree
  of objects described above never exists in memory in its entirety.  The
  objects are constructed on the fly in each call to a container method.

  The output classes elfutils::dwarf_output are template-compatible with
  the "logical view" interface above, but do not support any of the "raw"
  container variants.  These == and != comparisons are template-driven too,
  so all different classes can be compared.

  The output classes have template-driven copy constructors, so they can be
  copied from files or substructures of the elfutils::dwarf input classes.

  The elfutils::dwarf_output containers are mutable, unlike the input classes.

 */

// DWARF reader interfaces: front end to <libdw.h> routines
namespace elfutils
{
  template<typename key1, typename value1, class pair2>
  inline bool operator== (const std::pair<key1, value1> &a, const pair2 &b)
  {
    return a.first == b.first && a.second == b.second;
  }

  // One DWARF object file.
  class dwarf
  {
  private:
    template<const char *lookup_known (int)>
    static inline std::string known_name (int code)
    {
      const char *known = lookup_known (code);
      if (known != NULL)
	return std::string (known);
      std::ostringstream os;
      os.setf(std::ios::hex, std::ios::basefield);
      os << code;
      return os.str ();
    }

  public:
    static const char *known_attribute (int);
    static const char *known_tag (int);

    static inline std::string attribute_name (int code)
    {
      return known_name<known_attribute> (code);
    }
    static inline std::string tag_name (int code)
    {
      return known_name<known_tag> (code);
    }

    template<typename attribute>
    static inline std::string attribute_name (const attribute &attr)
    {
      int code = attr.first;
      return attribute_name (code);
    }

  private:
    // XXX make this an instance method to include irritant context
    static void throw_libdw (void) // XXX raises (...)
    {
      throw std::runtime_error(::dwarf_errmsg (-1));
    }
    static inline void xif (bool fail)
    {
      if (unlikely (fail))
	throw_libdw ();
    }

    template<typename raw, typename raw_element, typename element,
	     bool skip (const raw_element &)>
    class skipping_wrapper
    {
    protected:
      typedef typename raw::const_iterator raw_iterator;

      raw _m_raw;

    protected:
      inline skipping_wrapper (const raw &raw) : _m_raw (raw) {}

    public:
      inline skipping_wrapper (const skipping_wrapper &w) : _m_raw (w._m_raw) {}

      /*
	iterator: wraps raw iterator, skips DW_AT_sibling
	size/empty: search for DW_AT_sibling, adjust raw size
      */

      class const_iterator
	: public std::iterator<std::input_iterator_tag, element>
      {
	friend class skipping_wrapper<raw, raw_element, element, skip>;
      private:
	raw_iterator _m_raw;
	const raw_iterator _m_end;

	inline void jiggle ()
	{
	  while (_m_raw != _m_end && unlikely (skip (*_m_raw)))
	    ++_m_raw;
	}

      public:

	const_iterator (const const_iterator &i)
	  : _m_raw (i._m_raw), _m_end (i._m_end) {}

	// Start at the raw position and skip as necessary.
	const_iterator (const raw_iterator &begin, const raw_iterator &end)
	  : _m_raw (begin), _m_end (end)
	{
	  jiggle ();
	}

	inline const_iterator &operator= (const const_iterator &other)
	{
	  _m_raw = other._m_raw;
	  return *this;
	}

	inline bool operator== (const const_iterator &other) const
	{
	  return _m_raw == other._m_raw;
	}
	inline bool operator!= (const const_iterator &other) const
	{
	  return !(*this == other);
	}

	inline const_iterator &operator++ () // prefix
	{
	  ++_m_raw;
	  jiggle ();
	  return *this;
	}
	inline const_iterator operator++ (int) // postfix
	{
	  const_iterator prev = *this;
	  ++*this;
	  return prev;
	}

	inline element operator* () const
	{
	  return static_cast<element> (*_m_raw);
	}
      };

      inline const_iterator begin () const
      {
	return const_iterator (_m_raw.begin (), _m_raw.end ());
      }
      inline const_iterator end () const
      {
	const raw_iterator raw_end = _m_raw.end ();
	return const_iterator (raw_end, raw_end);
      }
    };

  public:
    /*
      getstring
    */

    class attribute;
    class attr_value;

    class debug_info_entry
    {
    private:
      ::Dwarf_Die _m_die;
      inline ::Dwarf_Die *thisdie () const
      {
	return const_cast< ::Dwarf_Die *> (&_m_die);
      }

      friend class dwarf;
    protected:

      inline debug_info_entry ()
      {
	memset (&_m_die, 0, sizeof _m_die);
      }

      inline debug_info_entry (::Dwarf *dw, ::Dwarf_Off off)
      {
	xif (::dwarf_offdie (dw, off, &_m_die) == NULL);
      }

    public:
      debug_info_entry (const debug_info_entry &die) : _m_die (die._m_die) {}

      // Containers, see class definitions below.
      class raw_children;
      inline raw_children raw_children () const;
      class raw_attributes;
      raw_attributes raw_attributes () const;
      class children;
      inline children children () const;
      class attributes;
      attributes attributes () const;

      inline int tag () const
      {
	int t = ::dwarf_tag (thisdie ());
	xif (t <= 0);
	return t;
      }

      bool has_children () const
      {
	int has = ::dwarf_haschildren (thisdie ());
	xif (has < 0);
	return has != 0;
      }

      /*
	const char *tag_name () const
	const_string tag_name () const // "name" or "0x123"
      */

      template<typename die>
      bool operator== (const die &other) const
      {
	return (attributes () == other.attributes ()
		&& children () == other.children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);
      }

      ::Dwarf_Off offset () const
      {
	return ::dwarf_dieoffset (thisdie ());
      }
    };

    // Container for raw list of child DIEs, intended to be a compatible with
    // a read-only, unidirectional subset of std::list<debug_info_entry>.
    class debug_info_entry::raw_children
    {
      friend class debug_info_entry;
    private:
      const debug_info_entry &_m_die;

    protected:
      inline raw_children (const debug_info_entry &die) : _m_die (die) {}

    public:
      inline raw_children (const raw_children &c) : _m_die (c._m_die) {}

      bool empty () const
      {
	return begin () == end ();
      }

      class const_iterator
	: public std::iterator<std::input_iterator_tag, debug_info_entry>
      {
	friend class debug_info_entry;
      private:
	debug_info_entry _m_die;

	inline const_iterator () {}
	inline const_iterator (const debug_info_entry &parent)
	{
	  int result = ::dwarf_child (parent.thisdie (), &_m_die._m_die);
	  xif (result < 0);
	}

      public:
	inline const_iterator (const const_iterator &i) : _m_die (i._m_die) {}

	inline const debug_info_entry &operator* () const
	{
	  return _m_die;
	}

	inline const_iterator &operator= (const const_iterator &other)
	{
	  _m_die = other._m_die;
	  return *this;
	}

	inline bool operator== (const const_iterator &other) const
	{
	  return _m_die._m_die.addr == other._m_die._m_die.addr;
	}
	inline bool operator!= (const const_iterator &other) const
	{
	  return !(*this == other);
	}

	inline const_iterator &operator++ () // prefix
	{
	  int result = ::dwarf_siblingof (&_m_die._m_die, &_m_die._m_die);
	  xif (result < 0);
	  if (result > 0)	// Hit the end.
	    *this = const_iterator ();
	  return *this;
	}
	inline const_iterator operator++ (int) // postfix
	{
	  const_iterator prev = *this;
	  ++*this;
	  return prev;
	}
      };
      const_iterator begin () const
      {
	return const_iterator (_m_die);
      }
      inline const_iterator end () const
      {
	return const_iterator ();
      }

      template<typename other_children>
      bool operator== (const other_children &other) const
      {
	return std::equal (begin (), end (), other.begin ());
      }
      template<typename other_children>
      bool operator!= (const other_children &other) const
      {
	return !(*this == other);
      }
    };

    // Container for list of raw attributes as (name, value) pairs,
    // intended to be compatible with a read-only, unidirectional
    // subset of std::list<std::pair<int, attr_value>>.
    class debug_info_entry::raw_attributes
    {
      friend class debug_info_entry;
    private:
      const debug_info_entry &_m_die;

      raw_attributes (const debug_info_entry &die) : _m_die (die) {}

    public:
      inline raw_attributes (const raw_attributes &a) : _m_die (a._m_die) {}

      size_t size () const;
      inline bool empty () const
      {
	return size () == 0;
      }

      class const_iterator
	: public std::iterator<std::input_iterator_tag, attribute>
      {
	friend class raw_attributes;
      private:
	debug_info_entry _m_die;
	ptrdiff_t _m_offset; // Offset for next iteration in dwarf_getattrs.
	::Dwarf_Attribute _m_attr;

	/* We get called up to twice per iteration.  The first time, we
	   store *ATTR in the instance variable and return DWARF_CB_OK so
	   that we might be called again.  The second time, we return
	   DWARF_CB_ABORT so that the iteration will stop at the next
	   attribute's offset.  */
	static int getattrs_callback (Dwarf_Attribute *attr, void *arg)
	{
	  const_iterator *i = static_cast<const_iterator *> (arg);
	  if (i->_m_attr.valp == NULL)
	    {
	      i->_m_attr = *attr;
	      return DWARF_CB_OK;
	    }
	  return DWARF_CB_ABORT;
	}

	inline const_iterator (const debug_info_entry &die, ptrdiff_t offset)
	  : _m_die (die), _m_offset (offset) {}

      public:
	inline const_iterator (const const_iterator &i)
	  : _m_die (i._m_die), _m_offset (i._m_offset), _m_attr (i._m_attr) {}

	inline const_iterator &operator= (const const_iterator &other)
	{
	  _m_die = other._m_die;
	  _m_offset = other._m_offset;
	  _m_attr = other._m_attr;
	  return *this;
	}

	inline bool operator== (const const_iterator &other) const
	{
	  return (_m_die._m_die.addr == other._m_die._m_die.addr
		  && _m_offset == other._m_offset);
	}
	inline bool operator!= (const const_iterator &other) const
	{
	  return !(*this == other);
	}

	inline const_iterator &operator++ () // prefix
	{
	  _m_attr.valp = NULL;
	  int result = ::dwarf_getattrs (&_m_die._m_die, &getattrs_callback,
					 (void *) this, _m_offset);
	  xif (result < 0);
	  _m_offset = result;
	  return *this;
	}
	inline const_iterator operator++ (int) // postfix
	{
	  const_iterator prev = *this;
	  ++*this;
	  return prev;
	}

	inline attribute operator* () const
	{
	  return attribute (_m_attr);
	}
      };
      inline const_iterator begin () const
      {
	const_iterator i = const_iterator (_m_die, 0);
	return ++i;
      }
      inline const_iterator end () const
      {
	return const_iterator (_m_die, 1);
      }

      // XXX can do faster internal (?)
      inline const_iterator find (int name) const
      {
	const_iterator i = begin ();
	while (i != end () && (*i).first != name)
	  ++i;
	return i;
      }
    };

    // Container for list of child DIEs, intended to be a compatible with
    // a read-only, unidirectional subset of std::list<debug_info_entry>.
    // Same as raw_children, but flattens DW_TAG_imported_unit children.
    class debug_info_entry::children : public debug_info_entry::raw_children
    {
      friend class debug_info_entry;
    private:

      inline children (const debug_info_entry &die)
	: raw_children::raw_children (die) {}

    public:
      inline children (const children &c) : raw_children (c) {}

      class const_iterator
	: public std::iterator<std::input_iterator_tag, debug_info_entry>
      {
	friend class children;
      private:

	typedef raw_children::const_iterator raw_iterator;
	std::stack<raw_iterator> _m_stack;
	const raw_iterator _m_end;

	/* Push and pop until either _m_stack.top () == _m_end or
	   it's looking at a DIE other than DW_TAG_imported_unit.  */
	inline void jiggle ()
	{
	  while (true)
	    {
	      raw_iterator &i = _m_stack.top ();

	      if (i == _m_end)
		{
		  /* We're at the end of this raw DIE.
		     Pop out to the iterator on the importing unit.  */
		  _m_stack.pop ();

		  if (_m_stack.empty ())
		    // That was the outermost unit, this is the end.
		    break;

		  continue;
		}

	      if ((*i).tag () == ::DW_TAG_imported_unit)
		// We have an imported unit.  Look at its referent.
		_m_stack.push ((*i).attributes ().at (::DW_AT_import)
			       .ref ().raw_children ().begin ());
	      else
		// This is some other DIE.  Iterate on it.
		break;
	    }
	}

	inline const_iterator (const raw_iterator &end) : _m_end (end) {}

	inline const_iterator (const raw_iterator &end, const raw_iterator &i)
	  : _m_end (end)
	{
	  _m_stack.push (i);
	  jiggle ();
	}

      public:
	inline const_iterator (const const_iterator &i)
	  : _m_stack (i._m_stack), _m_end (i._m_end) {}

	inline const_iterator &operator= (const const_iterator &other)
	{
	  _m_stack = other._m_stack;
	  return *this;
	}

	inline bool operator== (const const_iterator &other) const
	{
	  return _m_stack == other._m_stack;
	}
	inline bool operator!= (const const_iterator &other) const
	{
	  return !(*this == other);
	}

	inline const debug_info_entry &operator* () const
	{
	  return *_m_stack.top ();
	}

	inline const_iterator &operator++ () // prefix
	{
	  ++_m_stack.top ();
	  jiggle ();
	  return *this;
	}
	inline const_iterator operator++ (int) // postfix
	{
	  const_iterator prev = *this;
	  ++*this;
	  return prev;
	}
      };

      const_iterator begin () const
      {
	return const_iterator (raw_children::end (),
			       raw_children::begin ());
      }
      const_iterator end () const
      {
	return const_iterator (raw_children::end ());
      }

      template<typename other_children>
      bool operator== (const other_children &other) const
      {
	return std::equal (begin (), end (), other.begin ());
      }
      template<typename other_children>
      bool operator!= (const other_children &other) const
      {
	return !(*this == other);
      }
    };

  private:
    static inline bool skip_sibling (const attribute &attr)
    {
      return attr.first == ::DW_AT_sibling;
    }

    // Circumvent C++ namespace lookup.
    typedef class debug_info_entry::raw_attributes debug_info_entry_raw_attrs;
    typedef skipping_wrapper<debug_info_entry_raw_attrs,
			     attribute, attribute, skip_sibling>
    attributes_base;

  public:
    // Container for attributes, indexed by name, intended to be compatible
    // with a read-only subset of std::unordered_map<int, attr_value>.
    // This excludes DW_AT_sibling.
    class debug_info_entry::attributes : public attributes_base
    {
      friend class dwarf;
    private:
      inline attributes (const class raw_attributes &raw)
	: attributes_base (raw) {}

    public:
      inline attributes (const class attributes &a)
	: attributes_base (a) {}

      typedef attributes_base::const_iterator const_iterator;

      /*
	iterator: wraps raw_attributes iterator, skips DW_AT_sibling
	size/empty: search for DW_AT_sibling, adjust raw_attributes size
       */

      inline const_iterator find (int name) const
      {
	if (unlikely (name == ::DW_AT_sibling))
	  return end ();
	return const_iterator (_m_raw.find (name), _m_raw.end ());
      }

      inline const attr_value at (int name)
      {
	const_iterator i = find (name);
	if (unlikely (i == end ()))
	  throw std::out_of_range ("XXX");
	return (*i).second;
      }
      inline const attr_value operator[] (int name)
      {
	return at (name);
      }

      // We are rvalue-coercible into a std::map, which is sorted by name.
      inline operator std::map<int, attr_value> () const
      {
	return std::map<int, attr_value> (begin (), end ());
      }
      /*
      template<typename attrs>
      inline operator attrs () const
      {
	return attrs (begin (), end ());
      }
      */

      template<typename attrs>
      bool operator== (const attrs &other) const
      {
	/* Our container is unordered (i.e., in file order).  A set of
	   attributes is conceptually equal if all the pairs match,
	   regardless of the order.  But the std::equal algorithm will
	   compare corresponding elements in order.  So we need an ordered
	   map of our attributes for the comparison.  */
	const std::map<int, attr_value> mine = *this;
	const std::map<int, attr_value> his = other;
	return mine == his;
      }

      template<typename attrs>
      bool operator!= (const attrs &other) const
      {
	return !(*this == other);
      }
    };

    // This describes the value of an attribute.
    // XXX dummy for now
    class attr_value
    {
    public:
      attr_value () {}
      attr_value (const attr_value &v) {}

      inline bool operator== (const attr_value &other) const
      {
	return true;		// XXX dummy value comparison always true
      }
      inline bool operator!= (const attr_value &other) const
      {
	return !(*this == other);
      }

      debug_info_entry ref () const
      {
	return debug_info_entry (); // XXX dummy hack
      }
    };

    // This describes one attribute, equivalent to pair<const int, attr_value>.
    class attribute
    {
      friend class debug_info_entry::raw_attributes::const_iterator;
    private:
      const ::Dwarf_Attribute _m_attr;
      inline ::Dwarf_Attribute *thisattr () const
      {
	return const_cast< ::Dwarf_Attribute *> (&_m_attr);
      }

      class lhs
      {
	friend class attribute;
      private:
	const attribute &_m_attr;

	lhs (attribute &attr) : _m_attr (attr) {}

      public:
	operator int () const
	{
	  return ::dwarf_whatattr (_m_attr.thisattr ());
	}
      };

      attribute (const ::Dwarf_Attribute &attr)
	: _m_attr (attr), first (*this) {}

    public:
      lhs first;
      attr_value second;

      inline attribute (const attribute &a)
	: _m_attr (a._m_attr), first (*this) {}

      // This lets pair<...> x = (attribute) y work.
      template<typename value>
      operator std::pair<const int, value> () const
      {
	return std::make_pair (static_cast<int> (first), value (second));
      }

      template<typename pair>
      inline bool operator== (const pair &other) const
      {
	return first == other.first && second == other.second;
      }
      template<typename pair>
      inline bool operator!= (const pair &other) const
      {
	return !(*this == other);
      }
    };

    class compile_unit : public debug_info_entry
    {
    public:
      inline compile_unit (const debug_info_entry &die)
	: debug_info_entry (die) {}

      /*
	containers/iterators:

	lines
	macros

	abbrevs (punt)

      */
    };

    // Container for raw CUs in file order, intended to be compatible
    // with a read-only subset of std::list<raw_compile_unit>.
    class raw_compile_units
    {
      friend class dwarf;
    private:
      const dwarf &_m_file;

      raw_compile_units (const dwarf &file) : _m_file (file) {}

    public:
      inline raw_compile_units (const raw_compile_units &u)
	: _m_file (u._m_file) {}

      class const_iterator
	: public std::iterator<std::input_iterator_tag, compile_unit>
      {
	friend class raw_compile_units;
      private:
	debug_info_entry _m_die;
	const dwarf *_m_file;	// XXX
	::Dwarf_Off _m_next;	// XXX

	inline const_iterator ()
	  : _m_file (NULL), _m_next (-1) {} // end () value
	inline const_iterator (const dwarf &file) : _m_file (&file), _m_next (0)
	{
	  ++*this;
	}

      public:
	inline const_iterator (const const_iterator &i)
	  : _m_die (i._m_die), _m_file (i._m_file), _m_next (i._m_next) {}

	inline const debug_info_entry &operator* () const
	{
	  return _m_die;
	}

	inline const_iterator &operator= (const const_iterator &other)
	{
	  _m_die = other._m_die;
	  _m_next = other._m_next;
	  _m_file = other._m_file; // XXX
	  return *this;
	}

	inline bool operator== (const const_iterator &other) const
	{
	  return _m_next == other._m_next;
	}
	inline bool operator!= (const const_iterator &other) const
	{
	  return !(*this == other);
	}

	inline const_iterator &operator++ () // prefix
	{
	  // XXX should be rewritten to use libdw_findcu internals
	  // slow way for first crack to avoid DSO issues
	  _m_next = _m_file->nextcu (_m_next, _m_die.thisdie ());
	  return *this;
	}
	inline const_iterator operator++ (int) // postfix
	{
	  const_iterator prev = *this;
	  ++*this;
	  return prev;
	}
      };

      const_iterator begin () const
      {
	return const_iterator (_m_file);
      }
      inline const_iterator end () const
      {
	return const_iterator ();
      }
    };
    inline raw_compile_units raw_compile_units () const
    {
      return raw_compile_units::raw_compile_units (*this);
    }

  private:
    static inline bool skip_partial_unit (const compile_unit &unit)
    {
      switch (unit.tag ())
	{
	case ::DW_TAG_partial_unit:
	  return true;
	case ::DW_TAG_compile_unit:
	  return false;
	default:
	  throw std::exception(); // XXX invalid dwarf
	}
    }

    typedef skipping_wrapper<class raw_compile_units,
			     compile_unit, compile_unit,
			     skip_partial_unit> compile_units_base;

  public:

    // Container for logical CUs in file order, intended to be compatible
    // with a read-only subset of std::list<compile_unit>.
    class compile_units : public compile_units_base
    {
      friend class dwarf;
    private:
      compile_units (class raw_compile_units raw) : compile_units_base (raw) {}

    public:
      compile_units (const compile_units &u) : compile_units_base (u) {}

      template<typename units>
      bool operator== (const units &other) const
      {
	return std::equal (begin (), end (), other.begin ());
      }
      template<typename units>
      bool operator!= (const units &other) const
      {
	return !(*this == other);
      }
    };
    inline class compile_units compile_units () const
    {
      return compile_units::compile_units (raw_compile_units ());
    }

    /*
      raw CU: compile_unit or partial_unit, raw DIE children
      logical CU: compile_unit, DIE children with imported_unit replaced

      containers/iterators:
      raw CU in file order
      pubnames: list of (CU, DIE, FQ name string)
      aranges: list of (start, len, CU file offset)
      raw CU by addr (getarange_addr)

      logical CU in file order
      logical CU by addr

    */

  private:
    ::Dwarf *_m_dw;

  public:
    // XXX temp hack
    inline ::Dwarf_Off nextcu (::Dwarf_Off offset, ::Dwarf_Die *die) const
    {
      ::Dwarf_Off next;
      ::size_t header_size;
      int result = ::dwarf_nextcu (_m_dw, offset, &next, &header_size,
				   NULL, NULL, NULL);
      xif (result < 0);
      if (result == 0)
	xif (::dwarf_offdie (_m_dw, offset + header_size, die) == NULL);
      else
	memset (die, 0, sizeof *die);
      return next;
    }

    inline dwarf (::Dwarf *dw) : _m_dw (dw) {};

    inline dwarf (const dwarf &dw) : _m_dw (dw._m_dw) {};

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

  inline class dwarf::debug_info_entry::raw_children
  dwarf::debug_info_entry::raw_children () const
  {
    return raw_children::raw_children (*this);
  }

  inline class dwarf::debug_info_entry::children
  dwarf::debug_info_entry::children () const
  {
    return children::children (*this);
  }

  inline class dwarf::debug_info_entry::raw_attributes
  dwarf::debug_info_entry::raw_attributes () const
  {
    return raw_attributes::raw_attributes (*this);
  }

  inline class dwarf::debug_info_entry::attributes
  dwarf::debug_info_entry::attributes () const
  {
    return attributes::attributes (raw_attributes ());
  }
};

// DWARF writer interfaces (pure object construction)
// XXX probably move to separate file
namespace elfutils
{
  class dwarf_output
  {
  public:
    class compile_units;

    // XXX later
    class attr_value : public dwarf::attr_value
    {
    public:
      attr_value (const dwarf::attr_value &v) : dwarf::attr_value (v) {}
    };

    class debug_info_entry
    {
    public:

      class children : public std::list<debug_info_entry>
      {
	friend class debug_info_entry;
      private:
        children () {}

	template<typename childrens>
	children (const childrens &other)
	  : std::list<debug_info_entry> (other.begin (), other.end ()) {}
      };

      class attributes : public std::map<int, attr_value>
      {
	friend class debug_info_entry;
      private:
	attributes () {}

	template<typename attrs>
	attributes (const attrs &other)
	  : std::map<int, attr_value> (other.begin (), other.end ()) {}

      public:
	template<typename attrs>
	inline operator attrs () const
	{
	  return attrs (begin (), end ());
	}
      };

    private:
      const int _m_tag;
      attributes _m_attributes;
      children _m_children;

    public:
      debug_info_entry (int t) : _m_tag (t)
      {
	if (unlikely (t <= 0))
	  throw std::invalid_argument ("invalid tag");
      }

      /* The template constructor lets us copy in from any class that has
	 compatibly iterable containers for attributes and children.  */
      template<typename die>
      debug_info_entry (const die &die)
	: _m_tag (die.tag ()),
	  _m_attributes (die.attributes ()),
	  _m_children (die.children ())
      {}

      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children.empty ();
      }

      inline class children &children ()
      {
	return _m_children;
      }
      inline const class children &children () const
      {
	return _m_children;
      }

      inline class attributes &attributes ()
      {
	return _m_attributes;
      }
      inline const class attributes &attributes () const
      {
	return _m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);;
      }
    };

    typedef debug_info_entry::attributes::value_type attribute;

    class compile_unit : public debug_info_entry
    {
      friend class compile_units;
    private:
      inline compile_unit () : debug_info_entry (::DW_TAG_compile_unit) {}

      // XXX should be private
    public:
      template<typename die>
      compile_unit (const die &die) : debug_info_entry (die)
      {
	if (die.tag () != ::DW_TAG_compile_unit)
	  throw std::invalid_argument ("not a compile_unit entry");
      }

      /* XXX doesn't help
	public:
	compile_unit (const compile_unit &u) : debug_info_entry (u) {}
      */
    };

    // Main container anchoring all the output.
    class compile_units : public std::list<compile_unit>
    {
      friend class dwarf_output;
    private:
      // Default constructor: an empty container, no CUs.
      inline compile_units () {}

      // Constructor copying CUs from input container.
      template<typename input>
      compile_units(const input &units)
	: std::list<compile_unit> (units.begin (), units.end ())
      {}

    public:
      inline compile_unit &new_unit ()
      {
	compile_unit nu;
	push_back (nu);
	return back ();
      }

      template<typename other_children>
      bool operator== (const other_children &other) const
      {
	return std::equal (begin (), end (), other.begin ());
      }
      template<typename other_children>
      bool operator!= (const other_children &other) const
      {
	return !(*this == other);
      }
    };

  private:
    compile_units _m_units;

  public:
    class compile_units &compile_units ()
    {
      return _m_units;
    }
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  public:
    // Default constructor: an empty container, no CUs.
    inline dwarf_output () {}

    // Constructor copying CUs from an input file (dwarf or dwarf_output).
    template<typename input>
    dwarf_output (const input &dw) : _m_units (dw.compile_units ()) {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };
};

#endif	// <elfutils/dwarf>
