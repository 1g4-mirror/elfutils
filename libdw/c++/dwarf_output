/* elfutils::dwarf_output -- DWARF file generation in -*- C++ -*-
   Copyright (C) 2009 Red Hat, Inc.
   This file is part of Red Hat elfutils.

   Red Hat elfutils is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by the
   Free Software Foundation; version 2 of the License.

   Red Hat elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with Red Hat elfutils; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.

   In addition, as a special exception, Red Hat, Inc. gives You the
   additional right to link the code of Red Hat elfutils with code licensed
   under any Open Source Initiative certified open source license
   (http://www.opensource.org/licenses/index.php) which requires the
   distribution of source code with any binary distribution and to
   distribute linked combinations of the two.  Non-GPL Code permitted under
   this exception must only link to the code of Red Hat elfutils through
   those well defined interfaces identified in the file named EXCEPTION
   found in the source code files (the "Approved Interfaces").  The files
   of Non-GPL Code may instantiate templates or use macros or inline
   functions from the Approved Interfaces without causing the resulting
   work to be covered by the GNU General Public License.  Only Red Hat,
   Inc. may make changes or additions to the list of Approved Interfaces.
   Red Hat's grant of this exception is conditioned upon your not adding
   any new exceptions.  If you wish to add a new Approved Interface or
   exception, please contact Red Hat.  You must obey the GNU General Public
   License in all respects for all of the Red Hat elfutils code and other
   code used in conjunction with Red Hat elfutils except the Non-GPL Code
   covered by this exception.  If you modify this file, you may extend this
   exception to your version of the file, but you are not obligated to do
   so.  If you do not wish to provide this exception without modification,
   you must delete this exception statement from your version and license
   this file solely under the GPL without exception.

   Red Hat elfutils is an included package of the Open Invention Network.
   An included package of the Open Invention Network is a package for which
   Open Invention Network licensees cross-license their patents.  No patent
   license is granted, either expressly or impliedly, by designation as an
   included package.  Should you wish to participate in the Open Invention
   Network licensing program, please visit www.openinventionnetwork.com
   <http://www.openinventionnetwork.com>.  */

#ifndef _ELFUTILS_DWARF_OUTPUT
#define _ELFUTILS_DWARF_OUTPUT	1

#include "dwarf_edit"
#include "dwarf_ref_maker"
#include "dwarf_tracker"
#include <algorithm>
#include <functional>
#include <iterator>
#include <vector>
#include <tr1/unordered_set>

/* Read the comments for elfutils::dwarf first.

   The elfutils::dwarf_output class is template-compatible with the logical
   containers described in elfutils::dwarf and elfutils::dwarf_edit.

   The dwarf_output representation of the DWARF data is immutable once
   created.  The only way to create the object is by copy-construction
   from another compatible object: dwarf, dwarf_edit, or dwarf_output.
   Construction collects all the information necessary to generate the
   formatted DWARF sections.  */

namespace elfutils
{
  class dwarf_output_collector;

  class dwarf_output
  {
    friend class dwarf_output_collector;

  public:
    typedef dwarf_data::source_file source_file;
    typedef dwarf_data::directory_table directory_table;
    typedef dwarf_data::line_entry<source_file> line_entry;
    typedef dwarf_data::line_table<line_entry> line_table;
    typedef dwarf_data::line_info_table<directory_table,
					line_table> line_info_table;
    typedef dwarf_data::dwarf_enum dwarf_enum;
    typedef dwarf_data::range_list range_list;
    typedef dwarf_data::location_attr location_attr;

    class compile_units;
    class debug_info_entry;
    class attr_value;

  protected:
    static inline void never_copy ()
    {
      throw std::logic_error
	("must copy-construct top-level dwarf_output object instead");
    }

    template<typename input> class copier; // Below.

#if 0
    /* An iterator adapter for use in iterator-based constructors.
       collectify (iterator) yields an iterator on input where *i
       constructs output::value_type (input::value_type v, collector).  */
    template<typename input, typename output>
    static inline typename subr::argifier<input, output,
					  dwarf_output_collector &>::result_type
    collectify (const typename input::const_iterator &in,
		dwarf_output_collector &c)
    {
      return subr::argifier<input, output, dwarf_output_collector &> (c) (in);
    }
#endif

    /* Every kind of value is made by calling into the copier, which
       returns a const pointer into a value_set living in the collector.  */
    struct value
      : public dwarf_data::value<dwarf_output, false>
    {
      typedef const value_dispatch value_cell_type;

      typedef dwarf_data::value<dwarf_output> data;

      template<typename flavor, typename input>
      static inline value_dispatch *
      make (flavor *&, int, const input &, const subr::nothing &)
      {
	throw std::logic_error ("dwarf_output cannot be default-constructed");
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_string *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_string (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_identifier *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_identifier (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_reference *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_reference (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_flag *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_flag (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_address *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_address (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_rangelistptr *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_ranges (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_lineptr *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_line_info (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_constant *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_constant (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_constant_block *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_constant_block (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_dwarf_constant *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_dwarf_constant (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_file *&, int attr, const input &x, copier<input_dw> &c)
      {
	return c.add_source_file (attr, x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_line *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_source_line (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_column *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_source_column (x);
      }

      // XXX macptr

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_location *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_location (x);
      }
    };

  public:

    class debug_info_entry
    {
      friend class dwarf_output;
      friend class dwarf_output_collector;

    public:
      class attributes_type
	: public dwarf_data::attributes_type<dwarf_output, value>
      {
	friend class debug_info_entry;

      private:
	typedef dwarf_data::attributes_type<dwarf_output, value> _base;

	size_t _m_hash;

	inline attributes_type ()
	  : _base (), _m_hash (0)
	{}

	struct same_attr : public std::equal_to<value_type>
	{
	  bool operator () (const value_type &a,
			    const value_type &b) const
	  {
	    return a.first == b.first && a.second.is (b.second);
	  }
	};

      public:
	friend class subr::hashed_hasher<attributes_type>;
	typedef subr::hashed_hasher<attributes_type> hasher;

	template<typename input, typename arg_type>
	inline attributes_type (const input &other, arg_type &c)
	  : _base (other, c), _m_hash (0)
	{
	  // Precompute our hash value based on our contents.
	  for (iterator i = begin (); i != end (); ++i)
	    subr::hash_combine (_m_hash, *i);
	}

	inline bool is (const attributes_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (begin (), end (), these.begin (),
				 same_attr ()));
	}
      };

      class children_type
	: public std::vector<const debug_info_entry *>
      {
	friend class debug_info_entry;
      protected:
	typedef std::vector<const debug_info_entry *> _base;

	size_t _m_hash;

        inline children_type () {}

	struct deref
	  : public std::unary_function<const debug_info_entry *,
				       const debug_info_entry &>
	{
	  inline deref (...) {}

	  inline const debug_info_entry &
	  operator () (const debug_info_entry *x) const
	  {
	    return *x;
	  }
	};

      public:
	friend class subr::hashed_hasher<children_type>;
	typedef subr::hashed_hasher<children_type> hasher;

	typedef debug_info_entry value_type;
	typedef debug_info_entry &reference;
	typedef debug_info_entry &const_reference;
	typedef debug_info_entry *pointer;
	typedef debug_info_entry *const_pointer;

	template<typename input, typename copier>
	inline children_type (const input &other, copier &c)
	  : _base (), _m_hash (0)
	{
	  typename input::const_iterator in = other.begin ();
	  bool has_sibling = in != other.end ();
	  while (has_sibling)
	    {
	      const typename input::const_iterator here = in++;
	      has_sibling = in != other.end ();
	      push_back (NULL);
	      iterator out = end ();
	      --out;
	      const debug_info_entry *child = c.add_entry (out, here,
							   has_sibling);
	      subr::hash_combine (_m_hash, (uintptr_t) child);
	    }
	}

	inline bool is (const children_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (_base::begin (), _base::end (),
				 these._base::begin ()));
	}

	typedef subr::wrapped_input_iterator<
	  _base, deref, const debug_info_entry> const_iterator;
	typedef const_iterator iterator;

	inline const_iterator begin () const
	{
	  return const_iterator (_base::begin (), subr::nothing ());
	}

	inline const_iterator end () const
	{
	  return const_iterator (_base::end (), subr::nothing ());
	}
      };

      typedef children_type::iterator pointer;
      typedef children_type::const_iterator const_pointer;

    protected:
      value::value_reference _m_ref;
      const children_type *_m_children;
      const attributes_type *_m_attributes;
      void *_m_shape;
      size_t _m_hash;
      int _m_tag;

      // This is can only be used by the children_type constructor,
      // which immediately calls set.
      inline debug_info_entry ()
	: _m_children (NULL),
	  _m_attributes (NULL),
	  _m_shape (NULL),
	  _m_hash (0),
	  _m_tag (-1)
      {}

      template<typename input_die, typename copier_type>
      inline debug_info_entry (const pointer &at,
			       const input_die &die,
			       copier_type &c)
	: _m_ref (at, subr::nothing ()),
	  _m_children (c.add_children (die.children ())),
	  _m_attributes (c.add_attributes (die.attributes ())),
	  _m_shape (NULL),	// XXX
	  _m_hash (die.tag ()),
	  _m_tag (die.tag ())
      {
	subr::hash_combine (_m_hash, *_m_attributes);
	subr::hash_combine (_m_hash, *_m_children);
      }

    public:
      friend class subr::hashed_hasher<debug_info_entry>;
      typedef subr::hashed_hasher<debug_info_entry> hasher;

      inline bool is (const debug_info_entry &that) const
      {
	return (_m_hash == that._m_hash
		&& _m_tag == that._m_tag
		&& _m_attributes == that._m_attributes
		&& _m_children == that._m_children);
      }

      inline std::string to_string () const;

      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children->empty ();
      }

      inline const children_type &children () const
      {
	return *_m_children;
      }

      inline const attributes_type &attributes () const
      {
	return *_m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.tag () == tag ()
		&& other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);
      }

      inline ::Dwarf_Off identity () const
      {
	return (uintptr_t) this;
      }

      inline ::Dwarf_Off offset () const
      {
	return identity ();
      }
    };

    class attr_value
      : public dwarf_data::attr_value<dwarf_output, value>
    {
    private:
      typedef dwarf_data::attr_value<dwarf_output, value> _base;

    public:
      inline std::string to_string () const;

      /* These constructors can only be used by the containers
	 used in the collector.  The attributes_type map in an
	 actual debug_info_entry object is always const.  */
      inline attr_value ()
	: _base ()
      {}

      inline attr_value (const attr_value &other)
	: _base ()
      {
	this->_m_value = other._m_value;
      }

      /* Two identical values in fact share the same cell in the collector.
	 So we can use simple pointer comparison here.  */
      inline bool is (const attr_value &that) const
      {
	return this->_m_value == that._m_value;
      }

      // The is () test works only on a dwarf_output sharing the same collector.
      inline bool operator== (const attr_value &other) const
      {
	return is (other) || _base::operator== (other);
      }
      inline bool operator!= (const attr_value &other) const
      {
	return !(*this == other);
      }

      /* We can use the _m_value pointer itself as a perfect hash, because
	 all identical values share the same cell in the collector.  */
      struct hasher : public std::unary_function<attr_value, size_t>
      {
	inline size_t operator () (const attr_value &v) const
	{
	  return (uintptr_t) v._m_value;
	}
      };
    };

    typedef debug_info_entry::attributes_type::value_type attribute;

    class compile_unit
      : public dwarf_data::compile_unit<dwarf_output>
    {
    public:
      template<typename input, typename copier_type>
      inline compile_unit (const input &cu, copier_type &c)
	: dwarf_data::compile_unit<dwarf_output> (cu, c)
      {}
    };

    /* Main container anchoring all the output.

       This is the only container that actually lives in the dwarf_output
       object.  All others live in the dwarf_output_collector's sets, and
       we return const references to those copies.

       This list is actually mutable as a std::list.  But note that you
       should never remove a compile_unit, though you can reorder the
       list.  Nothing is ever removed from the collector, so your final
       output file can wind up with unreferenced data being encoded.  If
       you do remove any elements, then you should start a fresh collector
       and construct a new dwarf_output object by copying using that
       collector (or, equivalently, call o.compile_units ().recollect (C)
       on the new collector C).  */
    class compile_units
      : public dwarf_data::compile_units<dwarf_output>
    {
      friend class dwarf_output;

    private:
      inline compile_units (const compile_units &)
	: dwarf_data::compile_units<dwarf_output> ()
      {
	never_copy ();
      }

      // Constructor copying CUs from input container.
      template<typename input, typename tracker>
      inline compile_units (const input &other, tracker &t)
	: dwarf_data::compile_units<dwarf_output> (other, t)
      {}

    public:
      // Default constructor: an empty container, no CUs.
      inline compile_units () {}
    };

  private:
    compile_units _m_units;

  public:
    class compile_units &compile_units ()
    {
      return _m_units;
    }
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  private:
    // Bind default copy-constructor and prevent it.
    inline dwarf_output (const dwarf_output &)
    {
      throw std::logic_error ("copying dwarf_output requires a collector");
    }

  public:
    // Constructor for an empty file, can add to its compile_units ().
    inline dwarf_output () {}

    // Constructor copying CUs from an input file (can be any of dwarf,
    // dwarf_edit, or dwarf_output).
    // Copy construction instantiates a copier derived from the collector.
    template<typename input>
    inline dwarf_output (const input &dw, dwarf_output_collector &c,
			 copier<input> maker = copier<input> ())
      : _m_units (dw.compile_units (), maker (c))
    {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

  // Explicit specializations.
  template<>
  std::string to_string<dwarf_output::debug_info_entry>
  (const dwarf_output::debug_info_entry &);
  inline std::string dwarf_output::debug_info_entry::to_string () const
  {
    return elfutils::to_string (*this); // Use that.
  }
  template<>
  std::string
  to_string<dwarf_output::attribute> (const dwarf_output::attribute &);
  template<>
  std::string
  to_string<dwarf_output::attr_value> (const dwarf_output::attr_value &);

  inline std::string dwarf_output::attr_value::to_string () const
  {
    return elfutils::to_string (*this); // Use that.
  }

  class dwarf_output_collector
  {
    friend class dwarf_output;

  private:
    dwarf_path_finder<dwarf_output> _m_tracker;
    unsigned int _m_total;

    typedef dwarf_output::debug_info_entry die_type;
    typedef die_type::attributes_type attrs_type;
    typedef die_type::children_type children_type;
    typedef children_type::const_iterator die_ptr;

    // Simple value sets for leaf types.
    subr::value_set<dwarf_output::value::value_string> _m_strings;
    subr::value_set<dwarf_output::value::value_identifier> _m_identifiers;
    subr::value_set<dwarf_output::value::value_address> _m_address;
    subr::value_set<dwarf_output::value::value_rangelistptr> _m_ranges;
    subr::value_set<dwarf_output::value::value_lineptr> _m_line_info;
    subr::value_set<dwarf_output::value::value_constant> _m_constants;
    subr::value_set<dwarf_output::value::value_constant_block> _m_const_block;
    subr::value_set<dwarf_output::value::value_dwarf_constant> _m_dwarf_const;
    subr::value_set<dwarf_output::value::value_source_file> _m_source_file;
    subr::value_set<dwarf_output::value::value_source_line> _m_source_line;
    subr::value_set<dwarf_output::value::value_source_column> _m_source_column;
    subr::value_set<dwarf_output::value::value_location> _m_locations;

    // The set of Boolean flags is a doubleton.
    static const dwarf_output::value::value_flag flag_true;
    static const dwarf_output::value::value_flag flag_false;
    static inline const dwarf_output::value::value_flag *flag (bool flag)
    {
      return flag ? &flag_true : &flag_false;
    }

    // Set of attribute maps.
    subr::identity_set<attrs_type> _m_attr_sets;

    template<typename input, typename copier_type>
    inline const attrs_type *add_attributes (const input &x, copier_type &c)
    {
      return &*_m_attr_sets.insert (attrs_type (x, c)).first;
    }

    // Set of children lists.
    subr::identity_set<children_type> _m_broods;

    template<typename input, typename copier_type>
    inline const children_type *add_children (const input &x, copier_type &c)
    {
      return &*_m_broods.insert (children_type (x, c)).first;
    }

    struct die_info
    {
      unsigned int uses;
      bool with_sibling;
      bool without_sibling;

      inline die_info ()
	: uses (0), with_sibling (false), without_sibling (false)
      {}
    };

    // Set of unique DIEs.
    typedef subr::identity_map<die_type, die_info> die_map;
    die_map _m_unique;

    template<typename input, typename copier_type>
    inline const die_type *add_entry (const children_type::iterator &at,
				      const input &other, copier_type &c,
				      bool has_sibling)
    {
      std::pair <typename die_map::iterator, bool>
	ins = _m_unique.insert (std::make_pair (die_type (at, other, c),
						die_info ()));
      typename die_map::value_type &x = *ins.first;
      if (ins.second)
	{
	  assert (x.second.uses == 0);
	  if (has_sibling)
	    x.second.with_sibling = true;
	  else
	    x.second.without_sibling = true;
	  // XXX add_shape (x.first, !has_sibling);
	}
      x.second.uses++;
      ++_m_total;
      return &x.first;
    }

    struct shape_type
    {
      typedef std::vector<std::pair<int, int> > attrs_type;
      attrs_type _m_attrs;
      bool _m_has_children;
      size_t _m_hash;

      friend class subr::hashed_hasher<shape_type>;
      typedef subr::hashed_hasher<shape_type> hasher;

      inline void hashnadd (int name, int form);
      inline shape_type (const die_type &die, bool last_sibling);

      inline bool operator== (const shape_type &other) const
      {
	return (_m_hash == other._m_hash
		&& _m_has_children == other._m_has_children
		&& _m_attrs == other._m_attrs);
      }
      inline bool operator!= (const shape_type &other) const
      {
	return !(*this == other);
      }
    };

    typedef subr::nothing shape_info;

    typedef std::tr1::unordered_map<shape_type, shape_info,
				    shape_type::hasher> shape_map;
    shape_map _m_shapes;

    void add_shape (die_type &die, bool last_sibling);

  public:
    inline dwarf_output_collector ()
      : _m_total (0)
    {}

    static void die_stats (const die_map::value_type &elt)
    {
      std::cout << to_string (elt.first) << " uses="
		<< std::dec << elt.second.uses
		<< " (" << elt.second.with_sibling
		<< "," << elt.second.without_sibling << ")\n";
    }

    void stats () const
    {
      std::cout << "collected " << std::dec << _m_unique.size ()
		<< " unique of " << _m_total << " total DIEs\n";
      std::for_each (_m_unique.begin (), _m_unique.end (), die_stats);
    }
  };

  template<typename dw>
  class dwarf_output::copier
  {
    friend class dwarf_output;
  private:

    struct tracker
      : public dwarf_tracker_base<dw, dwarf_output>
    {
      typedef dw dwarf1;
      typedef dwarf_output dwarf2;

      typedef dwarf_tracker_base<dwarf1, dwarf2> _base;

      explicit tracker (const tracker &)
	: _base ()
      {
	throw std::logic_error ("not copy-constructible");
      }

      typedef typename _base::cu1 cu1;
      typedef typename _base::cu2 cu2;
      typedef typename _base::die1 die1;
      typedef typename _base::die2 die2;
      typedef typename _base::dwarf1_ref dwarf1_ref;

      typedef dwarf_path_finder<dwarf1> tracker1;
      typedef dwarf_path_finder<dwarf2> tracker2;

      tracker1 _m_left;
      tracker2 _m_right;

      struct ref_hasher : public std::unary_function<die2, size_t>
      {
	inline size_t operator () (const die2 &i) const
	{
	  return i->identity ();
	}
      };

      struct same_ref : public std::equal_to<die2>
      {
	inline bool operator () (const die2 &a, const die2 &b) const
	{
	  return a->identity () == b->identity ();
	}
      };

      typedef std::pair<const die2 *,
			std::tr1::unordered_set<die2, ref_hasher, same_ref>
			> equiv_list;
      typedef std::tr1::unordered_map< ::Dwarf_Off, equiv_list> equiv_map;
      equiv_map *_m_equiv;
      bool _m_delete_equiv;

      inline equiv_list *equiv_to (const die1 &a)
      {
	return &(*_m_equiv)[a->identity ()];
      }

      /* Predicate for DIEs "equal enough" to match as context for a subtree.
	 The definition we use is that the DIE has the same tag and all its
	 attributes are equal, excepting that references in attribute values
	 are not compared.  */
      struct equal_enough : public std::binary_function<die1, die2, bool>
      {
	inline bool operator () (const die1 &a, const die2 &b)
	{
	  if (a->tag () != b->tag ())
	    return false;
	  dwarf_tracker_base<dwarf1, dwarf2> t;
	  return (dwarf_comparator<dwarf1, dwarf2, true> (t)
		  .equals (a->attributes (), b->attributes ()));
	}
      };

    public:
      inline tracker (const dwarf_output_collector &c)
	: _m_right (c._m_tracker, true),
	  _m_equiv (new equiv_map), _m_delete_equiv (true)
      {}


      inline tracker (const tracker &proto,
		      typename _base::reference_match &matched,
		      const typename _base::left_context_type &lhs,
		      const typename _base::die1 &a,
		      const typename _base::right_context_type &rhs,
		      const typename _base::die2 &b)
	: _base (proto, matched, lhs, a, b)
      {}


      struct walk
      {
	typename tracker1::walk _m_left;
	typename tracker2::walk _m_right;

	inline walk (tracker *w, const cu1 &a, const cu2 &b)
	  : _m_left (&w->_m_left, a), _m_right (&w->_m_right, b)
	{}
      };

      struct step
      {
	typename tracker1::step _m_left;
	typename tracker2::step _m_right;

	inline step (tracker *w, const die1 &a, const die2 &b)
	  : _m_left (&w->_m_left, a), _m_right (&w->_m_right, b)
	{}
      };

      typedef typename tracker1::die_path left_context_type;
      inline const left_context_type &left_context (const die1 &die)
      {
	return _m_left.path_to (die);
      }

      typedef typename tracker2::die_path right_context_type;
      inline const right_context_type &right_context (const die2 &die)
      {
	return _m_right.path_to (die);
      }

      // Very cheap check for an obvious mismatch of contexts.
      inline bool context_quick_mismatch (const left_context_type &a,
					  const right_context_type &b)

      {
	return a.size () != b.size ();
      }

      // Full match when context_quick_mismatch has returned false.
      inline bool context_match (const left_context_type &a,
				 const right_context_type &b)
      {
	return std::equal (a.begin (), a.end (), b.begin (), equal_enough ());
      }

      class reference_match
      {
	friend class tracker;
      private:
	equiv_list *_m_elt;

      public:

	inline reference_match ()
	  : _m_elt (NULL)
	{}

	inline ~reference_match ()
	{
	  if (_m_elt != NULL)
	    _m_elt->first = NULL;
	}

	inline bool cannot_match () const
	{
	  return _m_elt == NULL;
	}

	inline void notice_match (const die2 &b, bool matches) const
	{
	  if (matches && _m_elt != NULL)
	    _m_elt->second.insert (b);
	}
      };

      inline bool
      reference_matched (reference_match &matched, const die1 &a, const die2 &b)
      {
	equiv_list *elt = equiv_to (a);
	if (elt->first == NULL)
	  {
	    /* Record that we have a walk in progress crossing A.
	       When MATCHED goes out of scope in our caller, its
	       destructor will reset ELT->first to clear this record.  */
	    elt->first = &b;
	    matched._m_elt = elt;

	    // Short-circuit if we have already matched B to A.
	    return elt->second.find (b) != elt->second.end ();
	  }

	/* We have a circularity.  We can tell because ELT->first remains
	   set from an outer recursion still in progress.

	   The circular chain of references rooted at A matches B if B is
	   also the root of its own circularity and everything along those
	   parallel chains matches.  If the chains hadn't matched so far,
	   we would not have kept following them to get here.

	   We recorded the B that arrived at the first comparison with A.
	   We actually record the pointer on the caller's stack rather
	   than a copy of B, just because the iterator might be larger.  */

	return *elt->first == b;
      }

      // Share the _m_seen maps with the prototype tracker,
      // but start a fresh walk from the given starting point.
      inline tracker (const tracker &proto, reference_match &,
		      const left_context_type &lhs, const die1 &a,
		      const right_context_type &rhs, const die2 &b)
	: _m_left (proto._m_left, lhs, a),
	  _m_right (proto._m_right, rhs, b),
	  _m_equiv (proto._m_equiv), _m_delete_equiv (false)
      {
	// We are starting a recursive consideration of a vs b.
      }

      struct maker
      {
	equiv_list *_m_elt;

	inline maker ()
	  : _m_elt (NULL)
	{}

	inline const debug_info_entry *entry () const
	{
	  return &**_m_elt->second.begin ();
	}

	inline ~maker ()
	{
	  if (_m_elt != NULL)
	    _m_elt->first = NULL;
	}
      };

      inline bool already_made (maker &m, const typename _base::die1 &in,
				const debug_info_entry::pointer &at)
      {
	equiv_list *equiv = equiv_to (in);
	if (equiv->first == NULL)
	  {
	    /* Record that we have a walk in progress crossing A.
	       When M goes out of scope in our caller, its
	       destructor will reset ELT->first to clear this record.  */
	    equiv->first = &at;
	    m._m_elt = equiv;

	    return equiv->second.begin () != equiv->second.end ();
	  }

	throw std::logic_error("XXX circularity");
      }

    };

    dwarf_output_collector *_m_collector;
    tracker *_m_tracker;

    inline copier ()
      : _m_collector (NULL), _m_tracker (NULL)
    {}

    inline ~copier ()
    {
      if (_m_tracker != NULL)
	delete _m_tracker;
    }

    copier &operator () (dwarf_output_collector &c)
    {
      _m_collector = &c;
      assert (_m_tracker == NULL);
      _m_tracker = new tracker (c);
      return *this;
    }

    inline operator dwarf_output_collector & ()
    {
      return *_m_collector;
    }

    template<typename input>
    inline const value::value_string *add_string (const input &x)
    {
      return _m_collector->_m_strings.add (x);
    }

    template<typename input>
    inline const value::value_string *add_identifier (const input &x)
    {
      return _m_collector->_m_identifiers.add (x);
    }

    template<typename input>
    inline const value::value_flag *add_flag (const input &x)
    {
      return dwarf_output_collector::flag (x);
    }

    template<typename input>
    inline const value::value_address *add_address (const input &x)
    {
      return _m_collector->_m_address.add (x);
    }

    template<typename input>
    inline const value::value_rangelistptr *add_ranges (const input &x)
    {
      return _m_collector->_m_ranges.add (x);
    }

    template<typename input>
    inline const value::value_lineptr *add_line_info (const input &x)
    {
      return _m_collector->_m_line_info.add (x, *_m_collector);
    }

    template<typename input>
    inline const value::value_constant *add_constant (const input &x)
    {
      return _m_collector->_m_constants.add (x);
    }

    template<typename input>
    inline const value::value_constant_block *
    add_constant_block (const input &x)
    {
      return _m_collector->_m_const_block.add (x);
    }

    template<typename input>
    inline const value::value_dwarf_constant *
    add_dwarf_constant (const input &x)
    {
      return _m_collector->_m_dwarf_const.add (x);
    }

    template<typename input>
    inline const value::value_source_file *add_source_file (int /*whatattr*/,
							    const input &x)
    {
      return _m_collector->_m_source_file.add (x);
    }

    template<typename input>
    inline const value::value_source_line *add_source_line (const input &x)
    {
      return _m_collector->_m_source_line.add (x);
    }

    template<typename input>
    inline const value::value_source_column *add_source_column (const input &x)
    {
      return _m_collector->_m_source_column.add (x);
    }

    template<typename input>
    inline const value::value_location *add_location (const input &x)
    {
      return _m_collector->_m_locations.add (x);
    }

    template<typename input>
    inline const debug_info_entry::attributes_type *
    add_attributes (const input &x)
    {
      return _m_collector->add_attributes (x, *this);
    }

    template<typename input>
    inline const debug_info_entry::children_type *
    add_children (const input &x)
    {
      return _m_collector->add_children (x, *this);
    }

    template<typename input>
    inline const debug_info_entry *
    add_entry (const debug_info_entry::children_type::iterator &at,
	       const input &in, bool has_sibling)
    {
      typename tracker::maker m;
      if (_m_tracker->already_made (m, in, at))
	return m.entry ();

      typename tracker::step into (_m_tracker, in, at);

      const debug_info_entry *die
	= _m_collector->add_entry (at, *in, *this, has_sibling);
      m._m_elt->second.insert (die->_m_ref.ref);
      return die;
    }

    template<typename input>
    inline const value::value_reference *add_reference (const input &to)
    {
      typename tracker::maker m;
      debug_info_entry::pointer at; // XXX
      if (_m_tracker->already_made (m, to, at))
	return &m.entry ()->_m_ref;

      throw std::logic_error ("XXX forward reference");
    }
  };
};

#endif	// <elfutils/dwarf_output>
