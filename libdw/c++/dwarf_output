/* elfutils::dwarf_output -- DWARF file generation in -*- C++ -*-
   Copyright (C) 2009 Red Hat, Inc.
   This file is part of Red Hat elfutils.

   Red Hat elfutils is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by the
   Free Software Foundation; version 2 of the License.

   Red Hat elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with Red Hat elfutils; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.

   In addition, as a special exception, Red Hat, Inc. gives You the
   additional right to link the code of Red Hat elfutils with code licensed
   under any Open Source Initiative certified open source license
   (http://www.opensource.org/licenses/index.php) which requires the
   distribution of source code with any binary distribution and to
   distribute linked combinations of the two.  Non-GPL Code permitted under
   this exception must only link to the code of Red Hat elfutils through
   those well defined interfaces identified in the file named EXCEPTION
   found in the source code files (the "Approved Interfaces").  The files
   of Non-GPL Code may instantiate templates or use macros or inline
   functions from the Approved Interfaces without causing the resulting
   work to be covered by the GNU General Public License.  Only Red Hat,
   Inc. may make changes or additions to the list of Approved Interfaces.
   Red Hat's grant of this exception is conditioned upon your not adding
   any new exceptions.  If you wish to add a new Approved Interface or
   exception, please contact Red Hat.  You must obey the GNU General Public
   License in all respects for all of the Red Hat elfutils code and other
   code used in conjunction with Red Hat elfutils except the Non-GPL Code
   covered by this exception.  If you modify this file, you may extend this
   exception to your version of the file, but you are not obligated to do
   so.  If you do not wish to provide this exception without modification,
   you must delete this exception statement from your version and license
   this file solely under the GPL without exception.

   Red Hat elfutils is an included package of the Open Invention Network.
   An included package of the Open Invention Network is a package for which
   Open Invention Network licensees cross-license their patents.  No patent
   license is granted, either expressly or impliedly, by designation as an
   included package.  Should you wish to participate in the Open Invention
   Network licensing program, please visit www.openinventionnetwork.com
   <http://www.openinventionnetwork.com>.  */

#ifndef _ELFUTILS_DWARF_OUTPUT
#define _ELFUTILS_DWARF_OUTPUT	1

#include "dwarf_edit"
#include "dwarf_ref_maker"
#include <algorithm>
#include <functional>
#include <iterator>
#include <vector>
#include <tr1/unordered_set>

/* Read the comments for elfutils::dwarf first.

   The elfutils::dwarf_output class is template-compatible with the logical
   containers described in elfutils::dwarf and elfutils::dwarf_edit.

   The dwarf_output representation of the DWARF data is immutable once
   created.  The only way to create the object is by copy-construction
   from another compatible object: dwarf, dwarf_edit, or dwarf_output.
   Construction collects all the information necessary to generate the
   formatted DWARF sections.  */

namespace elfutils
{
  class dwarf_output_collector;

#if 0
  class dwarf_output
  {
  public:
    class compile_units;
    class debug_info_entry;
    typedef debug_info_entry compile_unit;

  private:
    template<typename input>
    static inline const input &
    collect (dwarf_output_collector &c,
	     const subr::auto_ref<const input> &p)
    {
      return static_cast<const input &> (p);
    }

    template<typename input>
    static inline const debug_info_entry &
    collect (dwarf_output_collector &,
	     const typename input::debug_info_entry &);

  public:

    // XXX later
    class attr_value : public dwarf::attr_value
    {
    public:
      attr_value (const dwarf::attr_value &v) : dwarf::attr_value (v) {}
    };

    class debug_info_entry
    {
      friend class dwarf_output;

    public:
      typedef subr::hashed_unordered_map<int, attr_value> attributes_type;
      typedef subr::hashed_vector<debug_info_entry> children_type;

    private:
      const int _m_tag;
      const attributes_type _m_attributes;
      const children_type _m_children;
      size_t _m_hash;

      /* The template constructor lets us copy in from any class that has
	 compatibly iterable containers for attributes and children.  */
      template<typename die_type>
      debug_info_entry (const die_type &die, dwarf_output_collector &c)
	: _m_tag (die.tag ()),
	  _m_attributes (die.attributes ()),
	  _m_children (die.children ()),
	  _m_hash (0)
      {
	subr::hash_combine (_m_hash, _m_tag);
	subr::hash_combine (_m_hash, _m_attributes);
	subr::hash_combine (_m_hash, _m_children);
      }

    public:
      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children.empty ();
      }

      inline const children_type &children () const
      {
	return _m_children;
      }

      inline const attributes_type &attributes () const
      {
	return _m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);
      }
    };

    typedef debug_info_entry::attributes_type::value_type attribute;

  public:
    /* Main container anchoring all the output.

       This is the only container that actually lives in the dwarf_output
       object.  All others live in the dwarf_output_collector's sets, and
       we return const references to those copies.

       This vector is actually mutable as a std::vector.  But note that you
       should never remove a compile_unit, though you can reorder the
       vector.  Nothing is ever removed from the collector, so your final
       output file can wind up with unreferenced data being encoded.  If
       you do remove any elements, then you should start a fresh collector
       and construct a new dwarf_output object by copying using that
       collector (or, equivalently, call o.compile_units ().recollect (C)
       on the new collector C).  */
    class compile_units
      : public std::vector<subr::auto_ref<const debug_info_entry> >
    {
      friend class dwarf_output;
    private:
      typedef std::vector<subr::auto_ref<const debug_info_entry> > _base;

      template<typename input>
      struct make
	: public std::binary_function<typename input::value_type,
				      dwarf_output_collector &,
				      _base::value_type>
      {
	_base::value_type operator () (const typename input::value_type &cu,
				       dwarf_output_collector &c) const
	{
	  return _base::value_type (collect (c, cu));
	}
      };

      // Construct empty container.
      compile_units ()
	: _base ()
      {}

      // Constructor copying CUs from input container.
      template<typename input>
      compile_units (const input &units, dwarf_output_collector &c)
	: _base ()
      {
	for (typename input::const_iterator it = units.begin ();
	     it != units.end ();
	     ++it)
	  push_back (make<input> () (*it, c));
      }

    public:
      template<typename other_children>
      bool operator== (const other_children &other) const
      {
	return subr::container_equal (*this, other);
      }
      template<typename other_children>
      bool operator!= (const other_children &other) const
      {
	return !(*this == other);
      }

      void recollect (dwarf_output_collector &c)
      {
	std::transform (begin (), end (), begin (),
			std::bind2nd (make<compile_units> (), c));
      }
    };

  private:
    const compile_units _m_units;

  public:
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  public:
    // Constructor for an empty file, can add to its compile_units ().
    dwarf_output ()
      : _m_units ()
    {}

    // Constructor copying CUs from an input file (can be any of dwarf,
    // dwarf_edit, or dwarf_output).
    template<typename input>
    dwarf_output (const input &dw, dwarf_output_collector &c)
      : _m_units (dw.compile_units (), c)
    {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

#else  // XXX temp

  class dwarf_output
  {
    friend class dwarf_output_collector;

  public:
    typedef dwarf_data::source_file source_file;
    typedef dwarf_data::directory_table directory_table;
    typedef dwarf_data::line_entry<source_file> line_entry;
    typedef dwarf_data::line_table<line_entry> line_table;
    typedef dwarf_data::line_info_table<directory_table,
					line_table> line_info_table;
    typedef dwarf_data::dwarf_enum dwarf_enum;
    typedef dwarf_data::range_list range_list;
    typedef dwarf_data::location_attr location_attr;

    class compile_units;
    class debug_info_entry;
    class attr_value;

  protected:
    template<typename input> class copier; // Below.

#if 0
    /* An iterator adapter for use in iterator-based constructors.
       collectify (iterator) yields an iterator on input where *i
       constructs output::value_type (input::value_type v, collector).  */
    template<typename input, typename output>
    static inline typename subr::argifier<input, output,
					  dwarf_output_collector &>::result_type
    collectify (const typename input::const_iterator &in,
		dwarf_output_collector &c)
    {
      return subr::argifier<input, output, dwarf_output_collector &> (c) (in);
    }
#endif

    /* Every kind of value is made by calling into the copier, which
       returns a const pointer into a value_set living in the collector.  */
    struct value
      : public dwarf_data::value<dwarf_output, false>
    {
      typedef const value_dispatch value_cell_type;

      typedef dwarf_data::value<dwarf_output> data;

      template<typename flavor, typename input>
      static inline value_dispatch *
      make (flavor *&, int, const input &, const subr::nothing &)
      {
	throw std::logic_error ("dwarf_output cannot be default-constructed");
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_string *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_string (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_identifier *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_identifier (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_reference *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_reference (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_flag *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_flag (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_address *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_address (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_rangelistptr *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_ranges (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_lineptr *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_line_info (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_constant *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_constant (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_constant_block *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_constant_block (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_dwarf_constant *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_dwarf_constant (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_file *&, int attr, const input &x, copier<input_dw> &c)
      {
	return c.add_source_file (attr, x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_line *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_source_line (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_column *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_source_column (x);
      }

      // XXX macptr

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_location *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_location (x);
      }
    };

  public:

    class debug_info_entry
    {
      friend class dwarf_output_collector;
      friend class subr::create_container;

    public:
      class attributes_type
	: public dwarf_data::attributes_type<dwarf_output, value>
      {
	friend class debug_info_entry;

      private:
	typedef dwarf_data::attributes_type<dwarf_output, value> _base;

	size_t _m_hash;

	inline attributes_type ()
	  : _base (), _m_hash (0)
	{}

	struct same_attr : public std::equal_to<value_type>
	{
	  bool operator () (const value_type &a,
			    const value_type &b) const
	  {
	    return a.first == b.first && a.second.is (b.second);
	  }
	};

      public:
	friend class subr::hashed_hasher<attributes_type>;
	typedef subr::hashed_hasher<attributes_type> hasher;

	template<typename input, typename arg_type>
	inline attributes_type (const input &other, arg_type &c)
	  : _base (other, c), _m_hash (0)
	{
	  // Precompute our hash value based on our contents.
	  for (iterator i = begin (); i != end (); ++i)
	    subr::hash_combine (_m_hash, *i);
	}

	inline bool are (const attributes_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (begin (), end (), these.begin (),
				 same_attr ()));
	}
      };

      class children_type : public std::list<debug_info_entry>
      {
	friend class debug_info_entry;
      private:
        inline children_type () {}

	template<typename input, typename copier>
	static inline void
	copied (const iterator &out, const typename input::const_iterator &in,
		bool last_sibling, copier &c)
	{
	  c.copied (out, in, last_sibling);
	}

	template<typename input, typename copier>
	inline children_type (const input &other, copier &c)
	{
	  subr::create_container (this, other, c, copied<input, copier>);
	}

      public:
	typedef debug_info_entry value_type;
      };

      typedef children_type::iterator pointer;
      typedef children_type::const_iterator const_pointer;

    protected:
      int _m_tag;
      const attributes_type *_m_attributes;
      children_type _m_children;
      void *_m_shape;

      // This is can only be used by the children_type constructor,
      // which immediately calls set.
      inline debug_info_entry ()
	: _m_tag (-1), _m_attributes (NULL), _m_children (), _m_shape (NULL)
      {}

      template<typename die_type, typename input_dw>
      inline void set (const die_type &die, copier<input_dw> &c)
      {
	assert (_m_attributes == NULL);
	try
	  {
	    _m_tag = die.tag ();
	    _m_attributes = c.add_attributes (die.attributes ());
	    _m_children.swap (children_type (die.children (), c));
	  }
	catch (...)
	  {
	    // Never leave a partially-formed DIE.
	    _m_tag = -1;
	    _m_attributes = NULL;
	    _m_children.clear ();
	    throw;
	  };
      }

    public:

      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children.empty ();
      }

      inline const children_type &children () const
      {
	return _m_children;
      }

      inline const attributes_type &attributes () const
      {
	return *_m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.tag () == tag ()
		&& other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);;
      }

      inline ::Dwarf_Off identity () const
      {
	return (uintptr_t) this;
      }

      inline ::Dwarf_Off offset () const
      {
	return identity ();
      }
    };

    class attr_value
      : public dwarf_data::attr_value<dwarf_output, value>
    {
    private:
      typedef dwarf_data::attr_value<dwarf_output, value> _base;

    public:

      /* These constructors can only be used by the containers
	 used in the collector.  The attributes_type map in an
	 actual debug_info_entry object is always const.  */
      inline attr_value ()
	: _base ()
      {}

      inline attr_value (const attr_value &other)
	: _base ()
      {
	this->_m_value = other._m_value;
      }

      /* Two identical values in fact share the same cell in the collector.
	 So we can use simple pointer comparison here.  */
      inline bool is (const attr_value &that) const
      {
	return this->_m_value == that._m_value;
      }

      // The is () test works only on a dwarf_output sharing the same collector.
      inline bool operator== (const attr_value &other) const
      {
	return is (other) || _base::operator== (other);
      }
      inline bool operator!= (const attr_value &other) const
      {
	return !(*this == other);
      }

      /* We can use the _m_value pointer itself as a perfect hash, because
	 all identical values share the same cell in the collector.  */
      struct hasher : public std::unary_function<attr_value, size_t>
      {
	inline size_t operator () (const attr_value &v) const
	{
	  return (uintptr_t) v._m_value;
	}
      };
    };

    typedef debug_info_entry::attributes_type::value_type attribute;

    typedef dwarf_data::compile_unit<dwarf_output> compile_unit;

    // Main container anchoring all the output.
    class compile_units
      : public dwarf_data::compile_units<dwarf_output>
    {
      friend class dwarf_output;

    private:
      // Constructor copying CUs from input container.
      template<typename input, typename tracker>
      inline compile_units (const input &other, tracker &t)
	: dwarf_data::compile_units<dwarf_output> (other, t)
      {}

      inline compile_units (const compile_units &)
	: dwarf_data::compile_units<dwarf_output> ()
      {
	throw std::logic_error
	  ("must copy-construct top-level dwarf_output object instead");
      }

    public:
      // Default constructor: an empty container, no CUs.
      inline compile_units () {}
    };

  private:
    compile_units _m_units;

  public:
    class compile_units &compile_units ()
    {
      return _m_units;
    }
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  private:
    // Bind default copy-constructor and prevent it.
    inline dwarf_output (const dwarf_output &)
    {
      throw std::logic_error ("copying dwarf_output requires a collector");
    }

  public:
    // Constructor for an empty file, can add to its compile_units ().
    inline dwarf_output () {}

    // Constructor copying CUs from an input file (can be any of dwarf,
    // dwarf_edit, or dwarf_output).
    // Copy construction instantiates a copier derived from the collector.
    template<typename input>
    inline dwarf_output (const input &dw, dwarf_output_collector &c,
			 copier<input> maker = copier<input> ())
      : _m_units (dw.compile_units (), maker (c))
    {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

  // Explicit specializations.
  template<>
  std::string
  to_string<dwarf_output::attribute> (const dwarf_output::attribute &);
  template<>
  std::string
  to_string<dwarf_output::attr_value> (const dwarf_output::attr_value&);

#endif

  class dwarf_output_collector
  {
    friend class dwarf_output;

  private:
    typedef dwarf_output::debug_info_entry die_type;
    typedef die_type::children_type::const_iterator die_ptr;
    typedef die_type::attributes_type attrs_type;

    subr::value_set<dwarf_output::value::value_string> _m_strings;
    subr::value_set<dwarf_output::value::value_identifier> _m_identifiers;
    subr::value_set<dwarf_output::value::value_address> _m_address;
    subr::value_set<dwarf_output::value::value_rangelistptr> _m_ranges;
    subr::value_set<dwarf_output::value::value_lineptr> _m_line_info;
    subr::value_set<dwarf_output::value::value_constant> _m_constants;
    subr::value_set<dwarf_output::value::value_constant_block> _m_const_block;
    subr::value_set<dwarf_output::value::value_dwarf_constant> _m_dwarf_const;
    subr::value_set<dwarf_output::value::value_source_file> _m_source_file;
    subr::value_set<dwarf_output::value::value_source_line> _m_source_line;
    subr::value_set<dwarf_output::value::value_source_column> _m_source_column;
    subr::value_set<dwarf_output::value::value_location> _m_locations;

    static const dwarf_output::value::value_flag flag_true;
    static const dwarf_output::value::value_flag flag_false;
    static inline const dwarf_output::value::value_flag *flag (bool flag)
    {
      return flag ? &flag_true : &flag_false;
    }

    struct same_attrs : public std::equal_to<die_type::attributes_type>
    {
      bool operator () (const die_type::attributes_type &a,
			const die_type::attributes_type &b) const
      {
	return a.are (b);
      }
    };

    typedef std::tr1::unordered_set<attrs_type, attrs_type::hasher,
				    same_attrs> attrs_set;
    attrs_set _m_attr_sets;

    template<typename input, typename copier_type>
    inline const attrs_type *add_attributes (const input &x, copier_type &c)
    {
      return &*_m_attr_sets.insert (attrs_type (x, c)).first;
    }

    struct shape_type
    {
      typedef std::vector<std::pair<int, int> > attrs_type;
      attrs_type _m_attrs;
      bool _m_has_children;
      size_t _m_hash;

      friend class subr::hashed_hasher<shape_type>;
      typedef subr::hashed_hasher<shape_type> hasher;

      inline void hashnadd (int name, int form);
      inline shape_type (const die_type &die, bool last_sibling);

      inline bool operator== (const shape_type &other) const
      {
	return (_m_hash == other._m_hash
		&& _m_has_children == other._m_has_children
		&& _m_attrs == other._m_attrs);
      }
      inline bool operator!= (const shape_type &other) const
      {
	return !(*this == other);
      }
    };

    typedef subr::nothing shape_info;

    typedef std::tr1::unordered_map<shape_type, shape_info,
				    shape_type::hasher> shape_map;
    shape_map _m_shapes;

    void add_shape (die_type &die, bool last_sibling);

  };

  template<class dw>
  class dwarf_output::copier
    : public dwarf_ref_maker<dwarf_output, dw> // XXX temporary
  {
    friend class dwarf_output;
  private:
    dwarf_output_collector *_m_collector;

    inline copier ()
      : _m_collector (NULL)
    {}

    copier &operator () (dwarf_output_collector &c)
    {
      _m_collector = &c;
      return *this;
    }

    inline operator dwarf_output_collector & ()
    {
      return *_m_collector;
    }

    template<typename input>
    inline const value::value_string *add_string (const input &x)
    {
      return _m_collector->_m_strings.add (x);
    }

    template<typename input>
    inline const value::value_string *add_identifier (const input &x)
    {
      return _m_collector->_m_identifiers.add (x);
    }

    template<typename input>
    inline const value::value_reference *add_reference (const input &x)
    {
      // XXX temporary kludge (leak!)
      return new value::value_reference (x, *this);
    }

    template<typename input>
    inline const value::value_flag *add_flag (const input &x)
    {
      return dwarf_output_collector::flag (x);
    }

    template<typename input>
    inline const value::value_address *add_address (const input &x)
    {
      return _m_collector->_m_address.add (x);
    }

    template<typename input>
    inline const value::value_rangelistptr *add_ranges (const input &x)
    {
      return _m_collector->_m_ranges.add (x);
    }

    template<typename input>
    inline const value::value_lineptr *add_line_info (const input &x)
    {
      return _m_collector->_m_line_info.add (x, *_m_collector);
    }

    template<typename input>
    inline const value::value_constant *add_constant (const input &x)
    {
      return _m_collector->_m_constants.add (x);
    }

    template<typename input>
    inline const value::value_constant_block *
    add_constant_block (const input &x)
    {
      return _m_collector->_m_const_block.add (x);
    }

    template<typename input>
    inline const value::value_dwarf_constant *
    add_dwarf_constant (const input &x)
    {
      return _m_collector->_m_dwarf_const.add (x);
    }

    template<typename input>
    inline const value::value_source_file *add_source_file (int /*whatattr*/,
							    const input &x)
    {
      return _m_collector->_m_source_file.add (x);
    }

    template<typename input>
    inline const value::value_source_line *add_source_line (const input &x)
    {
      return _m_collector->_m_source_line.add (x);
    }

    template<typename input>
    inline const value::value_source_column *add_source_column (const input &x)
    {
      return _m_collector->_m_source_column.add (x);
    }

    template<typename input>
    inline const value::value_location *add_location (const input &x)
    {
      return _m_collector->_m_locations.add (x);
    }

    template<typename input>
    inline const debug_info_entry::attributes_type *
    add_attributes (const input &x)
    {
      return _m_collector->add_attributes (x, *this);
    }

    template<typename input_iter>
    inline void copied (const debug_info_entry::children_type::iterator &out,
			const input_iter &in, bool last_sibling)
    {
      equivalence (out, in);
      _m_collector->add_shape (*out, last_sibling);
    }
  };
};

#endif	// <elfutils/dwarf_output>
