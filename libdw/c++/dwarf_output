/* elfutils::dwarf_output -- DWARF file generation in -*- C++ -*-
   Copyright (C) 2009 Red Hat, Inc.
   This file is part of Red Hat elfutils.

   Red Hat elfutils is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by the
   Free Software Foundation; version 2 of the License.

   Red Hat elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with Red Hat elfutils; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.

   In addition, as a special exception, Red Hat, Inc. gives You the
   additional right to link the code of Red Hat elfutils with code licensed
   under any Open Source Initiative certified open source license
   (http://www.opensource.org/licenses/index.php) which requires the
   distribution of source code with any binary distribution and to
   distribute linked combinations of the two.  Non-GPL Code permitted under
   this exception must only link to the code of Red Hat elfutils through
   those well defined interfaces identified in the file named EXCEPTION
   found in the source code files (the "Approved Interfaces").  The files
   of Non-GPL Code may instantiate templates or use macros or inline
   functions from the Approved Interfaces without causing the resulting
   work to be covered by the GNU General Public License.  Only Red Hat,
   Inc. may make changes or additions to the list of Approved Interfaces.
   Red Hat's grant of this exception is conditioned upon your not adding
   any new exceptions.  If you wish to add a new Approved Interface or
   exception, please contact Red Hat.  You must obey the GNU General Public
   License in all respects for all of the Red Hat elfutils code and other
   code used in conjunction with Red Hat elfutils except the Non-GPL Code
   covered by this exception.  If you modify this file, you may extend this
   exception to your version of the file, but you are not obligated to do
   so.  If you do not wish to provide this exception without modification,
   you must delete this exception statement from your version and license
   this file solely under the GPL without exception.

   Red Hat elfutils is an included package of the Open Invention Network.
   An included package of the Open Invention Network is a package for which
   Open Invention Network licensees cross-license their patents.  No patent
   license is granted, either expressly or impliedly, by designation as an
   included package.  Should you wish to participate in the Open Invention
   Network licensing program, please visit www.openinventionnetwork.com
   <http://www.openinventionnetwork.com>.  */

#ifndef _ELFUTILS_DWARF_OUTPUT
#define _ELFUTILS_DWARF_OUTPUT	1

#include "dwarf_edit"
#include "dwarf_ref_maker"
#include "dwarf_tracker"
#include <algorithm>
#include <functional>
#include <iterator>
#include <vector>
#include <tr1/unordered_set>

/* Read the comments for elfutils::dwarf first.

   The elfutils::dwarf_output class is template-compatible with the logical
   containers described in elfutils::dwarf and elfutils::dwarf_edit.

   The dwarf_output representation of the DWARF data is immutable once
   created.  The only way to create the object is by copy-construction
   from another compatible object: dwarf, dwarf_edit, or dwarf_output.
   Construction collects all the information necessary to generate the
   formatted DWARF sections.  */

namespace elfutils
{
  class dwarf_output_collector;

  class dwarf_output
  {
  private:
    friend class dwarf_output_collector;
    friend class dwarf_data;
    typedef dwarf_output me;

  public:
    typedef dwarf_data::source_file source_file;
    typedef dwarf_data::directory_table directory_table;
    typedef dwarf_data::line_entry<source_file> line_entry;
    typedef dwarf_data::line_table<line_entry> line_table;
    typedef dwarf_data::line_info_table<directory_table,
					line_table> line_info_table;
    typedef dwarf_data::dwarf_enum dwarf_enum;
    typedef dwarf_data::range_list range_list;
    typedef dwarf_data::location_attr location_attr;

    class compile_units;
    class debug_info_entry;
    class attr_value;

  protected:
    static inline void never_copy ()
    {
      throw std::logic_error
	("must copy-construct top-level dwarf_output object instead");
    }

    template<typename input> class copier; // Below.

#if 0
    /* An iterator adapter for use in iterator-based constructors.
       collectify (iterator) yields an iterator on input where *i
       constructs output::value_type (input::value_type v, collector).  */
    template<typename input, typename output>
    static inline typename subr::argifier<input, output,
					  dwarf_output_collector &>::result_type
    collectify (const typename input::const_iterator &in,
		dwarf_output_collector &c)
    {
      return subr::argifier<input, output, dwarf_output_collector &> (c) (in);
    }
#endif

    /* Every kind of value is made by calling into the copier, which
       returns a const pointer into a value_set living in the collector.  */
    struct value
      : public dwarf_data::value<dwarf_output, false>
    {
      typedef const value_dispatch value_cell_type;

      typedef dwarf_data::value<dwarf_output> data;

#if 0
      template<typename flavor, typename input>
      static inline void
      make (const value_dispatch *&, flavor *&,
	    int, const input &, const subr::nothing &)
      {
	throw std::logic_error ("dwarf_output cannot be default-constructed");
      }
#endif

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_string *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_string (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_identifier *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_identifier (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_reference *&,
	    int, const input &x, copier_type &c)
      {
	v = c.add_reference (x, &v);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_flag *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_flag (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_address *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_address (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_rangelistptr *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_ranges (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_lineptr *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_line_info (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_constant *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_constant (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_constant_block *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_constant_block (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_dwarf_constant *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_dwarf_constant (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_source_file *&,
	    int attr, const input &x, copier_type &c)
      {
	v = c ().add_source_file (attr, x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_source_line *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_source_line (x);
      }

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_source_column *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_source_column (x);
      }

      // XXX macptr

      template<typename input, typename copier_type>
      static inline void
      make (const value_dispatch *&v, value_location *&,
	    int, const input &x, copier_type &c)
      {
	v = c ().add_location (x);
      }
    };

  public:

    class debug_info_entry
    {
      friend class dwarf_output;
      friend class dwarf_output_collector;

    public:
      class attributes_type
	: public dwarf_data::attributes_type<dwarf_output, value>
      {
	friend class dwarf_output;

      private:
	typedef dwarf_data::attributes_type<dwarf_output, value> _base;

	size_t _m_hash;

	inline attributes_type ()
	  : _base (), _m_hash (0)
	{}

	struct same_attr : public std::equal_to<value_type>
	{
	  bool operator () (const value_type &a,
			    const value_type &b) const
	  {
	    return a.first == b.first && a.second.is (b.second);
	  }
	};

	inline void do_hash ()
	{
	  // Precompute our hash value based on our contents.
	  for (iterator i = begin (); i != end (); ++i)
	    subr::hash_combine (_m_hash, *i);
	}

	template<typename iter>
	inline attributes_type (const iter &from, const iter &to)
	  : _base (from, to), _m_hash (0)
	{
	  do_hash ();
	}

      public:
	friend class subr::hashed_hasher<attributes_type>;
	typedef subr::hashed_hasher<attributes_type> hasher;

	template<typename input, typename arg_type>
	inline attributes_type (const input &other, arg_type &c)
	  : _base (other, c), _m_hash (0)
	{
	  do_hash ();
	}

	inline bool is (const attributes_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (begin (), end (), these.begin (),
				 same_attr ()));
	}
      };

      class children_type
	: public std::vector<const debug_info_entry *>
      {
	friend class dwarf_output;

      protected:
	typedef std::vector<const debug_info_entry *> _base;

	size_t _m_hash;

	inline void set_hash ()
	{
	  _m_hash = 0;
	  for (_base::iterator i = _base::begin (); i != _base::end (); ++i)
	    subr::hash_combine (_m_hash, (uintptr_t) *i);
	}

        inline children_type () {}

	template<typename iter>
	inline children_type (const iter &first, const iter &last)
	  : _base (first, last)
	{
	  set_hash ();
	}

	struct deref
	  : public std::unary_function<const debug_info_entry *,
				       const debug_info_entry &>
	{
	  inline deref (...) {}

	  inline const debug_info_entry &
	  operator () (const debug_info_entry *x) const
	  {
	    return *x;
	  }
	};

      public:
	friend class subr::hashed_hasher<children_type>;
	typedef subr::hashed_hasher<children_type> hasher;

	typedef debug_info_entry value_type;
	typedef debug_info_entry &reference;
	typedef debug_info_entry &const_reference;
	typedef debug_info_entry *pointer;
	typedef debug_info_entry *const_pointer;

#if 0
	template<typename input, typename copier>
	inline void add_child (const input &in, bool has_sibling, copier *c)
	{
	  push_back (NULL);
	  _base::iterator out (--_base::end ());
	  *out = c->_m_copier->add_entry
	    (size () - 1, const_iterator (out, subr::nothing ()), in,
	     has_sibling, c);
	}

	template<typename input, typename copier>
	inline children_type (const input &other, copier &c)
	  : _base (), _m_hash (0)
	{
	  typename input::const_iterator in = other.begin ();
	  bool has_sibling = in != other.end ();
	  while (has_sibling)
	    {
	      const typename input::const_iterator here = in++;
	      has_sibling = in != other.end ();
	      push_back (NULL);
	      _base::iterator out (--_base::end ());
	      const debug_info_entry *child = c.add_entry
		(out - _base::begin (), const_iterator (out, subr::nothing ()),
		 here, has_sibling);
	      *out = child;
	      subr::hash_combine (_m_hash, (uintptr_t) child);
	    }
	}
#endif

	inline bool is (const children_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (_base::begin (), _base::end (),
				 these._base::begin ()));
	}

	typedef subr::wrapped_input_iterator<
	  _base, deref, const debug_info_entry> const_iterator;
	typedef const_iterator iterator;

	inline const_iterator begin () const
	{
	  return const_iterator (_base::begin (), subr::nothing ());
	}

	inline const_iterator end () const
	{
	  return const_iterator (_base::end (), subr::nothing ());
	}
      };

      typedef children_type::iterator pointer;
      typedef children_type::const_iterator const_pointer;

    protected:
      value::value_reference _m_ref;
      const children_type *_m_children;
      const attributes_type *_m_attributes;
      void *_m_shape;
      size_t _m_hash;
      int _m_tag;

      // This is can only be used by the children_type constructor,
      // which immediately calls set.
      inline debug_info_entry ()
	: _m_children (NULL),
	  _m_attributes (NULL),
	  _m_shape (NULL),
	  _m_hash (0),
	  _m_tag (-1)
      {}

      inline debug_info_entry (int what,
			       const children_type *childs,
			       const attributes_type *attrs)
	: _m_ref (),		// XXX
	  _m_children (childs),
	  _m_attributes (attrs),
	  _m_shape (NULL),	// XXX
	  _m_tag (what)
      {
	set_hash ();
      }

      inline void set_hash ()
      {
	_m_hash = _m_tag;
	subr::hash_combine (_m_hash, *_m_attributes);
	subr::hash_combine (_m_hash, *_m_children);
      }

#if 0 // XXX
      template<typename input_die, typename copier_type,
	       typename attrs_dangle_type, typename children_dangle_type>
      inline debug_info_entry (const pointer &at,
			       const input_die &die,
			       copier_type &c,
			       attrs_dangle_type &attrs_dangle,
			       children_dangle_type &children_dangle)
	: _m_ref (at, subr::nothing ()),
	  _m_children (c.add_children (die.children (), &children_dangle)),
	  _m_attributes (c.add_attributes (die.attributes (), &attrs_dangle)),
	  _m_shape (NULL),	// XXX
	  _m_tag (die.tag ())
      {
	set_hash ();
      }

      template<typename die_type, typename copier_type>
      inline void set (const die_type &die, copier_type &c)
      {
	try
	  {
	    _m_tag = die.tag ();
	    _m_children = c.add_children (die.children (), NULL, 0);
	    _m_attributes = c.add_attributes (die.attributes (), NULL);
	    set_hash ();
	  }
	catch (...)
	  {
	    // Never leave a partially-formed DIE.
	    _m_tag = -1;
	    _m_children = NULL;
	    _m_attributes = NULL;
	    throw;
	  };
      }

      template<typename input_die, typename copier_type>
      inline debug_info_entry (const pointer &at,
			       const input_die &die,
			       copier_type &c)
	: _m_ref (at, subr::nothing ()),
	  _m_children (c.add_children (die.children ())),
	  _m_attributes (c.add_attributes (die.attributes ())),
	  _m_shape (NULL),	// XXX
	  _m_tag (die.tag ())
      {
	set_hash ();
      }
#endif

    public:
      friend class subr::hashed_hasher<debug_info_entry>;
      typedef subr::hashed_hasher<debug_info_entry> hasher;

      inline bool is (const debug_info_entry &that) const
      {
	return (_m_hash == that._m_hash
		&& _m_tag == that._m_tag
		&& _m_attributes == that._m_attributes
		&& _m_children == that._m_children);
      }

      inline std::string to_string () const;

      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children->empty ();
      }

      inline const children_type &children () const
      {
	return *_m_children;
      }

      inline const attributes_type &attributes () const
      {
	return *_m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.tag () == tag ()
		&& other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);
      }

      inline ::Dwarf_Off identity () const
      {
	return (uintptr_t) this;
      }

      inline ::Dwarf_Off offset () const
      {
	return identity ();
      }
    };

    class attr_value
      : public dwarf_data::attr_value<dwarf_output, value>
    {
      friend class dwarf_output;

    private:
      typedef dwarf_data::attr_value<dwarf_output, value> _base;

    public:
      inline std::string to_string () const;

      /* These constructors can only be used by the containers
	 used in the collector.  The attributes_type map in an
	 actual debug_info_entry object is always const.  */
      inline attr_value ()
	: _base ()
      {}

      inline attr_value (const attr_value &other)
	: _base ()
      {
	this->_m_value = other._m_value;
      }

      /* Two identical values in fact share the same cell in the collector.
	 So we can use simple pointer comparison here.  */
      inline bool is (const attr_value &that) const
      {
	return this->_m_value == that._m_value;
      }

      // The is () test works only on a dwarf_output sharing the same collector.
      inline bool operator== (const attr_value &other) const
      {
	return is (other) || _base::operator== (other);
      }
      inline bool operator!= (const attr_value &other) const
      {
	return !(*this == other);
      }

      /* We can use the _m_value pointer itself as a perfect hash, because
	 all identical values share the same cell in the collector.  */
      struct hasher : public std::unary_function<attr_value, size_t>
      {
	inline size_t operator () (const attr_value &v) const
	{
	  return (uintptr_t) v._m_value;
	}
      };
    };

    typedef debug_info_entry::attributes_type::value_type attribute;

    typedef dwarf_data::compile_unit<dwarf_output> compile_unit;

    /* Main container anchoring all the output.

       This is the only container that actually lives in the dwarf_output
       object.  All others live in the dwarf_output_collector's sets, and
       we return const references to those copies.

       This list is actually mutable as a std::list.  But note that you
       should never remove a compile_unit, though you can reorder the
       list.  Nothing is ever removed from the collector, so your final
       output file can wind up with unreferenced data being encoded.  If
       you do remove any elements, then you should start a fresh collector
       and construct a new dwarf_output object by copying using that
       collector (or, equivalently, call o.compile_units ().recollect (C)
       on the new collector C).  */
    class compile_units
      : public dwarf_data::compile_units<dwarf_output>
    {
      friend class dwarf_output;

    private:
      inline compile_units (const compile_units &)
	: dwarf_data::compile_units<dwarf_output> ()
      {
	never_copy ();
      }

      template<typename input, typename copier_type>
      static inline void
      cu_maker (const iterator &out,
		const typename input::const_iterator &in,
		bool,	// last-sibling
		copier_type &c)
      {
	c.make_unit (in, out);
      }

      // Constructor copying CUs from input container.
      template<typename input, typename tracker>
      inline compile_units (const input &other, tracker &t)
      {
	subr::create_container (this, other, t, cu_maker<input, tracker>);
      }

    public:
      // Default constructor: an empty container, no CUs.
      inline compile_units () {}
    };

  private:
    compile_units _m_units;

  public:
    class compile_units &compile_units ()
    {
      return _m_units;
    }
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  private:
    // Bind default copy-constructor and prevent it.
    inline dwarf_output (const dwarf_output &)
    {
      throw std::logic_error ("copying dwarf_output requires a collector");
    }

  public:
    // Constructor for an empty file, can add to its compile_units ().
    inline dwarf_output () {}

    // Constructor copying CUs from an input file (can be any of dwarf,
    // dwarf_edit, or dwarf_output).
    // Copy construction instantiates a copier derived from the collector.
    template<typename input>
    inline dwarf_output (const input &dw, dwarf_output_collector &c,
			 copier<input> maker = copier<input> ())
      : _m_units (dw.compile_units (), maker (c))
    {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

  // Explicit specializations.
  template<>
  std::string to_string<dwarf_output::debug_info_entry>
  (const dwarf_output::debug_info_entry &);
  inline std::string dwarf_output::debug_info_entry::to_string () const
  {
    return elfutils::to_string (*this); // Use that.
  }
  template<>
  std::string
  to_string<dwarf_output::attribute> (const dwarf_output::attribute &);
  template<>
  std::string
  to_string<dwarf_output::attr_value> (const dwarf_output::attr_value &);

  inline std::string dwarf_output::attr_value::to_string () const
  {
    return elfutils::to_string (*this); // Use that.
  }

  class dwarf_output_collector
  {
    friend class dwarf_output;

  private:
    dwarf_path_finder<dwarf_output> _m_tracker;
    unsigned int _m_total;

    typedef dwarf_output::debug_info_entry die_type;
    typedef die_type::attributes_type attrs_type;
    typedef die_type::children_type children_type;
    typedef children_type::const_iterator die_ptr;

    // Simple value sets for leaf types.
    subr::value_set<dwarf_output::value::value_string> _m_strings;
    subr::value_set<dwarf_output::value::value_identifier> _m_identifiers;
    subr::value_set<dwarf_output::value::value_address> _m_address;
    subr::value_set<dwarf_output::value::value_rangelistptr> _m_ranges;
    subr::value_set<dwarf_output::value::value_lineptr> _m_line_info;
    subr::value_set<dwarf_output::value::value_constant> _m_constants;
    subr::value_set<dwarf_output::value::value_constant_block> _m_const_block;
    subr::value_set<dwarf_output::value::value_dwarf_constant> _m_dwarf_const;
    subr::value_set<dwarf_output::value::value_source_file> _m_source_file;
    subr::value_set<dwarf_output::value::value_source_line> _m_source_line;
    subr::value_set<dwarf_output::value::value_source_column> _m_source_column;
    subr::value_set<dwarf_output::value::value_location> _m_locations;

    // The set of Boolean flags is a doubleton.
    static const dwarf_output::value::value_flag flag_true;
    static const dwarf_output::value::value_flag flag_false;
    static inline const dwarf_output::value::value_flag *flag (bool flag)
    {
      return flag ? &flag_true : &flag_false;
    }

    // Set of attribute maps.
    subr::identity_set<attrs_type> _m_attr_sets;

    inline const attrs_type *add_attributes (const attrs_type &candidate)
    {
      return &*_m_attr_sets.insert (candidate).first;
    }

    // Set of children lists.
    subr::identity_set<children_type> _m_broods;

    inline const children_type *add_children (const children_type &candidate)
    {
      return &*_m_broods.insert (candidate).first;
    }

    struct die_info
    {
      unsigned int uses;
      bool with_sibling;
      bool without_sibling;

      inline die_info ()
	: uses (0), with_sibling (false), without_sibling (false)
      {}
    };

    // Set of unique DIEs.
    typedef subr::identity_map<die_type, die_info> die_map;
    typedef die_map::value_type die_info_pair;
    die_map _m_unique;

    inline const die_type *add_entry (int tag,
				      const children_type *children,
				      const attrs_type *attrs)
    {
      std::pair <die_map::iterator, bool>
	ins = _m_unique.insert (std::make_pair (die_type (tag, children, attrs),
						die_info ()));
      die_map::value_type &x = *ins.first;
      if (ins.second)
	{
	  assert (x.second.uses == 0);
	  // XXX add_shape (x.first, !has_sibling);
	}
      x.second.uses++;
      ++_m_total;
      return &x.first;
    }

    struct shape_type
    {
      typedef std::vector<std::pair<int, int> > attrs_type;
      attrs_type _m_attrs;
      bool _m_has_children;
      size_t _m_hash;

      friend class subr::hashed_hasher<shape_type>;
      typedef subr::hashed_hasher<shape_type> hasher;

      inline void hashnadd (int name, int form);
      inline shape_type (const die_type &die, bool last_sibling);

      inline bool operator== (const shape_type &other) const
      {
	return (_m_hash == other._m_hash
		&& _m_has_children == other._m_has_children
		&& _m_attrs == other._m_attrs);
      }
      inline bool operator!= (const shape_type &other) const
      {
	return !(*this == other);
      }
    };

    typedef subr::nothing shape_info;

    typedef std::tr1::unordered_map<shape_type, shape_info,
				    shape_type::hasher> shape_map;
    shape_map _m_shapes;

    void add_shape (die_type &die, bool last_sibling);

  public:
    inline dwarf_output_collector ()
      : _m_total (0)
    {}

    static void die_stats (const die_map::value_type &elt)
    {
      std::cout << to_string (elt.first) << " uses="
		<< std::dec << elt.second.uses
		<< " (" << elt.second.with_sibling
		<< "," << elt.second.without_sibling << ")\n";
    }

    void stats () const
    {
      std::cout << "collected " << std::dec << _m_unique.size ()
		<< " unique of " << _m_total << " total DIEs\n";
      std::for_each (_m_unique.begin (), _m_unique.end (), die_stats);
    }
  };

  template<typename dw>
  class dwarf_output::copier
  {
    friend class dwarf_output;
  private:
    typedef typename dw::debug_info_entry input_die;
    typedef typename input_die::children_type::const_iterator input_die_ptr;

    struct tracker
      : public dwarf_tracker_base<dw, dwarf_output>
    {
      typedef dw dwarf1;
      typedef dwarf_output dwarf2;

      typedef dwarf_tracker_base<dwarf1, dwarf2> _base;

      explicit tracker (const tracker &)
	: _base ()
      {
	throw std::logic_error ("not copy-constructible");
      }

      typedef typename _base::cu1 cu1;
      typedef typename _base::cu2 cu2;
      typedef typename _base::die1 die1;
      typedef typename _base::die2 die2;
      typedef typename _base::dwarf1_ref dwarf1_ref;

      typedef dwarf_path_finder<dwarf1> tracker1;
      typedef dwarf_path_finder<dwarf2> tracker2;

      tracker1 _m_left;
      tracker2 _m_right;

      /* Predicate for DIEs "equal enough" to match as context for a subtree.
	 The definition we use is that the DIE has the same tag and all its
	 attributes are equal, excepting that references in attribute values
	 are not compared.  */
      struct equal_enough : public std::binary_function<die1, die2, bool>
      {
	inline bool operator () (const die1 &a, const die2 &b)
	{
	  if (a->tag () != b->tag ())
	    return false;
	  dwarf_tracker_base<dwarf1, dwarf2> t;
	  return (dwarf_comparator<dwarf1, dwarf2, true> (t)
		  .equals (a->attributes (), b->attributes ()));
	}
      };

    public:
      inline tracker (const dwarf_output_collector &c)
	: _m_right (c._m_tracker, true)
      {}

      inline tracker (const tracker &proto,
		      typename _base::reference_match &matched,
		      const typename _base::left_context_type &lhs,
		      const typename _base::die1 &a,
		      const typename _base::right_context_type &rhs,
		      const typename _base::die2 &b)
	: _base (proto, matched, lhs, a, b)
      {}


      struct walk
      {
	typename tracker1::walk _m_left;
	typename tracker2::walk _m_right;

	inline walk (tracker *w, const cu1 &a, const cu2 &b)
	  : _m_left (&w->_m_left, a), _m_right (&w->_m_right, b)
	{}
      };

      struct step
      {
	typename tracker1::step _m_left;
	typename tracker2::step _m_right;

	inline step (tracker *w, const die1 &a, const die2 &b)
	  : _m_left (&w->_m_left, a), _m_right (&w->_m_right, b)
	{}
      };

      typedef typename tracker1::die_path left_context_type;
      inline const left_context_type &left_context (const die1 &die)
      {
	return _m_left.path_to (die);
      }

      typedef typename tracker2::die_path right_context_type;
      inline const right_context_type &right_context (const die2 &die)
      {
	return _m_right.path_to (die);
      }

      // Very cheap check for an obvious mismatch of contexts.
      inline bool context_quick_mismatch (const left_context_type &a,
					  const right_context_type &b)

      {
	return a.size () != b.size ();
      }

      // Full match when context_quick_mismatch has returned false.
      inline bool context_match (const left_context_type &a,
				 const right_context_type &b)
      {
	return std::equal (a.begin (), a.end (), b.begin (), equal_enough ());
      }

#if 0		   // XXX
      // Share the _m_seen maps with the prototype tracker,
      // but start a fresh walk from the given starting point.
      inline tracker (const tracker &proto, reference_match &,
		      const left_context_type &lhs, const die1 &a,
		      const right_context_type &rhs, const die2 &b)
	: _m_left (proto._m_left, lhs, a),
	  _m_right (proto._m_right, rhs, b),
	  _m_equiv (proto._m_equiv), _m_delete_equiv (false)
      {
	// We are starting a recursive consideration of a vs b.
      }
#endif
    };

    dwarf_output_collector *_m_collector;
    tracker *_m_tracker;

    /* An attribute is "dangling" if it's a reference to a DIE not yet
       reached in the copying walk.  An attribute is "pending" if it's a
       reference to a DIE that has a pending_entry but no final entry.

       A pending_entry itself is "dangling" if it contains any dangling
       attributes or dangling child entries.  Each dangling attribute and
       each dangling child contributes one to _m_dangling_count.

    */

    struct seen;		// Below.
    struct pending_entry
    {
      dwarf_data::attributes_type<dwarf_output, value> _m_attributes;
      std::vector<seen *> _m_children;
      const int _m_tag;

      unsigned int _m_dangling_count;
      unsigned int _m_pending_count;

      // Backpointers to other _m_children vectors that point to us.
      std::deque<seen *> _m_parents;

      inline pending_entry (int tag)
	: _m_attributes (), _m_children (), _m_tag (tag),
	  _m_dangling_count (0), _m_pending_count (0),
	  _m_parents ()
      {}

      // Count one pending or dangling attribute or child.
      inline void count_pending (bool dangle)
      {
	++_m_pending_count;
	if (dangle)
	  ++_m_dangling_count;
      }

      inline bool dangling () const
      {
	return _m_dangling_count > 0;
      }

      inline bool complete () const
      {
	return _m_pending_count == 0;
      }

      inline void add_parent (seen *parent)
      {
	_m_parents.push_back (parent);
      }

      /* One of our pending attributes or children is no longer dangling.
	 Either it's still pending or it's actually final now.  */
      inline bool resolve_dangling (bool ready)
      {
	assert (_m_dangling_count > 0);
	assert (_m_pending_count >= _m_dangling_count);
	if (ready)
	  --_m_pending_count;
	return --_m_dangling_count == 0;
      }

      // One of our pending attributes or children is final now.
      inline bool resolve_pending ()
      {
	assert (_m_pending_count > _m_dangling_count);
	assert (_m_pending_count > 0);
	return --_m_pending_count == 0;
      }

      struct propagate_resolve_dangling
	: public std::unary_function<seen *, void>
      {
	copier *_m_copier;
	inline propagate_resolve_dangling (copier *c) : _m_copier (c) {}
	inline void operator () (seen *parent) const
	{
	  parent->resolve_dangling (_m_copier, false);
	}
      };

      // We are no longer dangling!  Propagate the bookkeeping to each parent.
      inline void parents_resolve_dangling (copier *c)
      {
	assert (_m_dangling_count == 0);
	assert (_m_pending_count > 0);
	std::for_each (_m_parents.begin (), _m_parents.end (),
		       propagate_resolve_dangling (c));
      }

      struct get_final_child
	: public std::unary_function<seen *, const debug_info_entry *>
      {
	inline get_final_child (...) {}
	inline const debug_info_entry *operator () (seen *child) const
	{
	  assert (child->_m_final != NULL);
	  return child->_m_final;
	}
      };
      typedef subr::wrapped_input_iterator<
	std::vector<seen *>, get_final_child> final_child_iterator;
      static inline final_child_iterator
      get_final_children (const typename std::vector<seen *>::const_iterator &i)
      {
	return final_child_iterator (i, subr::nothing ());
      }

      inline const debug_info_entry *final (dwarf_output_collector *c)
      {
	assert (complete ());

	const debug_info_entry::attributes_type *attrs
	  = c->add_attributes (debug_info_entry::attributes_type
			       (_m_attributes.begin (), _m_attributes.end ()));

	const debug_info_entry::children_type *children
	  = c->add_children (debug_info_entry::children_type
			     (get_final_children (_m_children.begin ()),
			      get_final_children (_m_children.end ())));

	return c->add_entry (_m_tag, children, attrs);
      }

      inline void resolve_parents (copier *c)
      {
	while (!_m_parents.empty ())
	  {
	    _m_parents.front ()->resolve_pending (c);
	    _m_parents.pop_front ();
	  }
      }
    };

    /* This is what we record about each input DIE we have considered.
       An attr_value that is a dangling reference to a DIE not yet
       built in the output has one of these in place of a value_reference.
       These all live in the _m_seen map, one per input-side DIE.  */
    struct entry_copier;	// Below.
    struct seen
      : public value::value_dispatch
    {
      ::Dwarf_Off _m_offset; // XXX debugging only

      // Set if we are building this in the copying walk right now.
      entry_copier *_m_building;

      // Completed DIE in the collector, or NULL.
      const debug_info_entry *_m_final;

      // Pending entry made with new, or NULL.
      pending_entry *_m_pending;

      /* Here we record back-pointers to the attributes_type objects that
	 point to us.  Each time we record one, we increment its count in
	 the pending_entry record.  */
      std::deque<std::pair<seen *, const value_dispatch **> > _m_patch;

      inline seen ()
	: _m_building (NULL), _m_final (NULL), _m_pending (NULL), _m_patch ()
      {}

      /* Called by entry_copier::add_reference, below.
	 We're adding a reference attribute pointing to this input entry.  */

      inline const value::value_dispatch *
      refer (seen *referrer, const value::value_dispatch **backptr)
      {
	if (_m_final != NULL)
	  // It's finished, resolve the final reference.
	  return &_m_final->_m_ref;

	/* This entry is still dangling or pending.  Record the
	   back-pointer to us so we can fix it up later, and
	   count the referrer's pending reference.  */
	_m_patch.push_back (std::make_pair (referrer, backptr));
	referrer->_m_pending->count_pending (_m_pending == NULL);

	return this;
      }

      /* One dangling attribute or child is no longer dangling.
	 See if that completes us.  */
      inline void resolve_dangling (copier *c, bool final)
      {
	if (_m_pending->resolve_dangling (final)
	    // We no longer have any dangling references!
	    && !made (c))
	  {
	    // We are still pending ourselves.
	    _m_pending->parents_resolve_dangling (c);
	  }
      }

      inline void resolve_pending (copier *c)
      {
	if (_m_pending->resolve_pending ())
	  // We no longer have any pending references or children!
	  finish_pending (c);
      }

      struct resolve_ref
	: public std::unary_function<std::pair<seen *,
					       const value_dispatch **> &,
				     void>
      {
	copier *_m_copier;
	inline resolve_ref (copier *c) : _m_copier (c) {}
	inline void
	operator () (std::pair<seen *, const value_dispatch **> &p) const
	{
	  p.first->resolve_dangling (_m_copier, false);
	}
      };

      // add_entry has just created the output DIE we'll refer to.
      inline bool made (copier *c)
      {
	if (_m_pending->complete ())
	  {
	    // It's all done.  Finish up all our references.
	    finish_pending (c);
	    return true;
	  }

	// It's still pending, but no longer dangling.  Adjust bookkeeping.
	std::for_each (_m_patch.begin (), _m_patch.end (), resolve_ref (c));
	return false;
      }

      // Our pending_entry is complete.  Resolve all pointers to us.
      inline void finish_pending (copier *c)
      {
	// Create it in the collector.
	_m_final = _m_pending->final (c->_m_collector);

	/* Tell each parent pending_entry whose children vector points
	   to us.  When we're the last unfinished child, this will
	   recursively finish the pending parent too.  */
	_m_pending->resolve_parents (c);

	// No more pending_entry required!
	delete _m_pending;
	_m_pending = NULL;

	/* Fix up each reference attribute pointing to us.  When we're
	   the last dangling reference, this will recursively finish
	   the referrer pending_entry too.  */
	while (!_m_patch.empty ())
	  {
	    seen *&referrer = _m_patch.front ().first;
	    const value_dispatch **&backptr = _m_patch.front ().second;
	    // Sanity check that this really points to a struct seen.
	    dynamic_cast<const seen &> (**backptr);
	    *backptr = &_m_final->_m_ref;
	    referrer->resolve_dangling (c, true);
	    _m_patch.pop_front ();
	  }
      }

      void dump (copier *) const
      {
	std::cout << _m_pending->_m_patch.size () << " backptrs\n";
      }

#if 0
      // This entry is being baked, so update all pointers to us.
      inline void resolve (children_copier *c, const debug_info_entry *die)
      {
	std::cout << "XXX " << c->_m_depth << ": resolving "
		  << dwarf::tags::identifier (die->_m_tag)
		  << " ";
	dump (c->_m_copier);

	pending_entry *p = _m_pending;
	_m_pending = NULL;
	final (die, c);

	if (p->_m_patch.empty ())
	  {
	    /* This is a pending entry in the children_copier, not yet
	       reified.  This means what resolved us was the definition
	       of a sibling to which we contained a forward reference.
	       We patch the children_type still being created, and
	       remove the record of it having had this pending child.  */
	    c->resolve_pending (this, p, die);
	    return;
	  }

	assert (p->_m_pending_patch.empty ());

	/* Replace all _m_pending_children vectors' elements pointing to us
	   with the final entry pointer.  First we update that vector's
	   pointer in place.  Then we call pending_container_info::resolve
	   to count down until each such children_type vector is ready to
	   move into the collector.  */
	do
	  {
	    std::cout << "\tleaves "
		      << p->_m_patch.top ().first->second._m_dangling
		      << " dangling children in "
		      << (void *) &p->_m_patch.top ().first->second
		      << "\n";
	    p->_m_patch.top ().first->first->finish
	      (p->_m_patch.top ().second, die);
	    p->_m_patch.top ().first->second.resolve
	      (c, p->_m_patch.top ().first->first);
	    p->_m_patch.pop ();
	  }
	while (!p->_m_patch.empty ());

	delete p;
      }
#endif
    };

    // This object lives while we are copying one particular input DIE.
    struct entry_copier
    {
      copier *_m_copier;
      seen *_m_in;
      pending_entry *_m_out;
      unsigned int _m_depth;

      /* On creation we set _m_building in DIE's record.
	 It should never be set already.  */
      inline entry_copier (copier *c, unsigned int depth,
			   seen *die, const input_die &in)
	: _m_copier (c),
	  _m_in (die),
	  _m_out (new pending_entry (in.tag ())),
	  _m_depth (depth)
      {
	if (unlikely (_m_in->_m_building != NULL))
	  throw std::runtime_error ("detected cycle in logical DWARF tree");
	_m_in->_m_building = this;
      }

      // On destruction, we clear _m_building.
      inline ~entry_copier ()
      {
	assert (_m_in->_m_building == this);
	_m_in->_m_building = NULL;

	if (_m_in->_m_pending == NULL)
	  delete _m_out;
	else
	  assert (_m_in->_m_pending == _m_out);
      }

      /* Populate _m_out from the corresponding input DIE.
	 This invokes all the main work of copying.
	 The interesting parts happen in add_reference and add_child, below.  */
      inline void populate (const input_die &in)
      {
	assert (_m_in->_m_pending == NULL);
	_m_in->_m_pending = _m_out;

	try
	  {
	    // This calls add_reference for each pending reference.
	    _m_out->_m_attributes.set (in.attributes (), *this);

	    for (input_die_ptr i = in.children ().begin ();
		 i != in.children ().end ();
		 ++i)
	      add_child (i);
	  }
	catch (...)
	  {
	    _m_in->_m_pending = NULL;
	    throw;
	  }

      }

      /* Complain if we still have dangling references.
	 If not, it should be impossible to have pending entries left.  */
      inline void demand_complete () const
      {
	if (_m_out->dangling ())
	  throw std::runtime_error
	    ("compile_unit contains dangling reference attributes");
	assert (_m_out->complete ());
      }

      // We're adding a reference attribute inside populate, above.
      inline const value::value_dispatch *
      add_reference (const input_die_ptr &to,
		     const value::value_dispatch **backptr)
      {
	return _m_copier->enter_seen (*to)->refer (_m_in, backptr);
      }

      // We're adding a child entry inside populate, above.
      inline void add_child (const input_die_ptr &in)
      {
	seen *child = _m_copier->enter_seen (*in);
	_m_out->_m_children.push_back (child);

	/* If the input used DW_TAG_imported_unit, then the logical walk
	   can hit the same DIE twice.  If so, we short-circuit right here.  */
	if (child->_m_final == NULL)
	  {
	    if (child->_m_pending == NULL)
	      make_child (child, in);

	    /* Record a back-pointer to this parent entry,
	       and count its new child as pending.  */
	    child->_m_pending->add_parent (_m_in);
	    _m_out->count_pending (child->_m_pending->dangling ());
	  }
      }

      /* We're adding a new child entry not seen before.
	 Recurse on a new entry_copier object to create it.  */
      inline void make_child (seen *child, const input_die_ptr &in)
      {
	{
	  //  typename tracker::die2 at (); // XXX
	  // typename tracker::step step (_m_copier->_m_tracker, in, at);

	  entry_copier maker (_m_copier, _m_depth + 1, child, *in);
	  maker.populate (*in);
	}

	// Fix up dangling references to this entry now that we have it.
	child->made (_m_copier);
      }

      // Use "c ()" as a shorthand to get the copier out of the entry_copier.
      inline copier &operator () () const
      {
	return *_m_copier;
      }
    };

    /* Create a whole CU in the output.
     */
    inline void
    make_unit (const typename dw::compile_units::const_iterator &in,
	       const compile_units::iterator &out)
    {
      typename tracker::walk into (_m_tracker, in, out);

      entry_copier maker (this, 0, enter_seen (*in), *in);
      maker.populate (*in);

      maker.demand_complete ();
    }

#if 0 //XXX
    inline const debug_info_entry *
    add_entry (size_t i, const debug_info_entry::children_type::iterator &at,
	       const input_die_ptr &in, bool has_sibling,
	       children_copier *step)
    {
      /* If the input used DW_TAG_imported_unit, then the logical walk
	 can hit the same DIE twice.  If so, we short-circuit right here.  */

      seen *die = enter_seen (in);
      if (die->_m_final != NULL)
	return die->_m_final;

      if (die->_m_pending == NULL)
	make_child (die, in, depth);

      step->record_pending_child (i, die);
      return NULL; // XXX &die->_m_pending->first;
    }
#endif


    typedef std::tr1::unordered_map< ::Dwarf_Off, seen> seen_map;
    seen_map _m_seen;
    unsigned int _m_defined;	// _m_seen entries not entirely dangling

    inline seen *enter_seen (const input_die &in)
    {
      seen *die = &_m_seen[in.identity ()];
      die->_m_offset = in.offset (); // XXX debugging only
      return die;
    }

    inline copier ()
      : _m_collector (NULL), _m_tracker (NULL),
	_m_seen (), _m_defined (0)
    {}

    inline ~copier ()
    {
      if (_m_tracker != NULL)
	delete _m_tracker;
    }

    copier &operator () (dwarf_output_collector &c)
    {
      _m_collector = &c;
      assert (_m_tracker == NULL);
      _m_tracker = new tracker (c);
      return *this;
    }

    inline operator dwarf_output_collector & ()
    {
      return *_m_collector;
    }

    template<typename input>
    inline const value::value_string *add_string (const input &x)
    {
      return _m_collector->_m_strings.add (x);
    }

    template<typename input>
    inline const value::value_string *add_identifier (const input &x)
    {
      return _m_collector->_m_identifiers.add (x);
    }

    template<typename input>
    inline const value::value_flag *add_flag (const input &x)
    {
      return dwarf_output_collector::flag (x);
    }

    template<typename input>
    inline const value::value_address *add_address (const input &x)
    {
      return _m_collector->_m_address.add (x);
    }

    template<typename input>
    inline const value::value_rangelistptr *add_ranges (const input &x)
    {
      return _m_collector->_m_ranges.add (x);
    }

    template<typename input>
    inline const value::value_lineptr *add_line_info (const input &x)
    {
      return _m_collector->_m_line_info.add (x, *_m_collector);
    }

    template<typename input>
    inline const value::value_constant *add_constant (const input &x)
    {
      return _m_collector->_m_constants.add (x);
    }

    template<typename input>
    inline const value::value_constant_block *
    add_constant_block (const input &x)
    {
      return _m_collector->_m_const_block.add (x);
    }

    template<typename input>
    inline const value::value_dwarf_constant *
    add_dwarf_constant (const input &x)
    {
      return _m_collector->_m_dwarf_const.add (x);
    }

    template<typename input>
    inline const value::value_source_file *add_source_file (int /*whatattr*/,
							    const input &x)
    {
      return _m_collector->_m_source_file.add (x);
    }

    template<typename input>
    inline const value::value_source_line *add_source_line (const input &x)
    {
      return _m_collector->_m_source_line.add (x);
    }

    template<typename input>
    inline const value::value_source_column *add_source_column (const input &x)
    {
      return _m_collector->_m_source_column.add (x);
    }

    template<typename input>
    inline const value::value_location *add_location (const input &x)
    {
      return _m_collector->_m_locations.add (x);
    }

#if 0 // XXX
    struct children_copier : public copier_step<dw>
    {
      std::map<size_t, seen *> _m_pending;
      debug_info_entry::children_type *_m_candidate;
      unsigned int _m_depth;

      void dump_pending ()
      {
	std::cout << "XXX " << _m_depth << ": "
		  << this->_m_copier->_m_seen.size () << " seen, "
		  << this->_m_copier->_m_defined << " defined, "
		  << _m_pending.size ()
		  << " pending:\n";
	for (typename std::map<size_t, seen *>::iterator
	       i = _m_pending.begin (); i != _m_pending.end (); ++i)
	  {
	    std::cout << "\t[" << i->first << "] ";
	    i->second->dump (this->_m_copier);
	  }
      }

      explicit inline
      children_copier (const typename dw::debug_info_entry::children_type &x,
		       copier *c, unsigned int depth)
	: copier_step<dw> (c),
	  _m_pending (),
	  _m_candidate (new debug_info_entry::children_type),
	  _m_depth (depth)
      {
	input_die_ptr in = x.begin ();
	bool has_sibling = in != x.end ();
	while (has_sibling)
	  {
	    const input_die_ptr here = in++;
	    has_sibling = in != x.end ();

	    /* Now we store the child.  If it comes out a pending entry,
	       this records backpointers into _m_candidate.  If it comes
	       out a final entry and its creation resolves some pending
	       entries, those will be resolved on the fly.  That can
	       include resolving a pending entry just created in a prior
	       element of _m_candidate, in which case that element is fixed
	       up on the fly.  Because of that, we can't compute the hash
	       until we're finished.  */
	    _m_candidate->add_child (here, has_sibling, this);
	  }
	_m_candidate->set_hash ();
      }

      inline ~children_copier ()
      {
	if (_m_candidate != NULL)
	  delete _m_candidate;
	collect_stale_pending ();
      }

      /* When add_entry is returning a pending_entry pointer,
	 it calls this first.  We record the mapping of this
	 index to the pending entry in _m_pending so we can
	 give it a back-pointer if we get reified.  We also
	 record momentarily in the pending_entry record
	 that this index points back there, see below.  */
      inline void record_pending_child (size_t i, seen *entry)
      {
	entry->_m_pending->_m_pending_patch.push_back (i);
	_m_pending[i] = entry;
      }

      /* If a pending entry is resolved before its parent's children_type
	 has been reified, it calls here.  This can only mean that it is
	 being resolved by the creation of a sibling to which it had a
	 forward reference.  We patch it in place here, and remove its
	 record from _m_pending.  */
      inline void resolve_pending (seen *ref, pending_entry *info,
				   const debug_info_entry *final)
      {
	assert (!info->_m_pending_patch.empty ());
	do
	  {
	    const size_t i = info->_m_pending_patch.front ();
	    _m_candidate->finish (i, final);
	    assert (_m_pending[i] == ref);
	    _m_pending.erase (i);
	    info->_m_pending_patch.pop_front ();
	  }
	while (!info->_m_pending_patch.empty ());
      }

      /* If this children_type contains pending entries and was new in
	 _m_pending_children, then we get here.  Now we can give each
	 pending_entry its back-pointer to us.  */
      inline void reify (typename pending_children_map::value_type &v)
      {
	assert (v.first == _m_candidate);
	_m_candidate = NULL;
	do
	  {
	    const size_t i = _m_pending.begin ()->first;
	    seen *const ref = _m_pending.begin ()->second;
	    ref->_m_pending->_m_pending_patch.clear ();
	    ref->_m_pending->_m_patch.push (std::make_pair (&v, i));
	    ++v.second._m_dangling;
	    _m_pending.erase (_m_pending.begin ());
	  }
	while (!_m_pending.empty ());
      }

      /* If reify is not called, this is called instead.
	 We just clear out all the _m_pending_patch lists we set up.  */
      inline void collect_stale_pending ()
      {
	while (!_m_pending.empty ())
	  {
	    _m_pending.begin ()->second->_m_pending->_m_pending_patch.clear ();
	    _m_pending.erase (_m_pending.begin ());
	  }
      }

      /* This is called each time one dangling reference is resolved.
	 When the number still dangling in an attributes_type reaches
	 zero, then it can be reified in the collector.  */
      void resolve_pending_attrs (typename pending_attrs_map::value_type *p)
      {
	if (p->second.resolve (this, p->first))
	  this->_m_copier->_m_pending_attr_sets.erase (p->first);
      }

      // Partially resolve a pending entry with final children.
      inline void
      resolve_entry (seen *ref, const debug_info_entry::children_type *children)
      {
	pending_entry *entry = ref->_m_pending;
	entry->_m_children = children;
	if (entry->_m_attributes != NULL)
	  resolve_entry (ref);
      }

      /* When a pending entry's attributes and children are both resolved,
	 we can move it into the collector.  */
      inline void
      resolve_entry (seen *ref)
      {
	// This back-patches all the pointers to the old pending entry.
	ref->resolve (this,
		      this->_m_copier->_m_collector->add_entry
		      (debug_info_entry (ref->_m_pending->_m_tag,
					 ref->_m_pending->_m_children,
					 ref->_m_pending->_m_attributes),
		       false)); //XXX has_sibling
      }
    };

    inline const debug_info_entry::children_type *
    add_children (const typename dw::debug_info_entry::children_type &x,
		  pending_children_info **dangling, unsigned int depth)
    {
      // Construct a candidate children_type vector.
      children_copier c (x, this, depth);

      if (c._m_pending.empty ())
	// No dangling references.  Put it into the collector right here.
	return _m_collector->add (*c._m_candidate);

      c.dump_pending ();

      if (unlikely (dangling == NULL))
	throw std::logic_error ("XXX compile_unit has dangling children");

      /* We have some dangling references, so this has to
	 go into the copier's pending set instead.  */
      std::pair<typename pending_children_map::iterator, bool> p
	= (_m_pending_children.insert
	   (std::make_pair (c._m_candidate, pending_children_info ())));
      if (p.second)
	/* This is a new entry in the pending set.
	   All its pending_entry children need their backpointers set up.  */
	c.reify (*p.first);
      else
	assert (p.first->second._m_dangling > 0);
      *dangling = &p.first->second;
      return p.first->first;
    }
#endif
  };
};

#endif	// <elfutils/dwarf_output>
