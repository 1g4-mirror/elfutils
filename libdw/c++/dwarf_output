/* elfutils::dwarf_output -- DWARF file generation in -*- C++ -*-
   Copyright (C) 2009 Red Hat, Inc.
   This file is part of Red Hat elfutils.

   Red Hat elfutils is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by the
   Free Software Foundation; version 2 of the License.

   Red Hat elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with Red Hat elfutils; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.

   In addition, as a special exception, Red Hat, Inc. gives You the
   additional right to link the code of Red Hat elfutils with code licensed
   under any Open Source Initiative certified open source license
   (http://www.opensource.org/licenses/index.php) which requires the
   distribution of source code with any binary distribution and to
   distribute linked combinations of the two.  Non-GPL Code permitted under
   this exception must only link to the code of Red Hat elfutils through
   those well defined interfaces identified in the file named EXCEPTION
   found in the source code files (the "Approved Interfaces").  The files
   of Non-GPL Code may instantiate templates or use macros or inline
   functions from the Approved Interfaces without causing the resulting
   work to be covered by the GNU General Public License.  Only Red Hat,
   Inc. may make changes or additions to the list of Approved Interfaces.
   Red Hat's grant of this exception is conditioned upon your not adding
   any new exceptions.  If you wish to add a new Approved Interface or
   exception, please contact Red Hat.  You must obey the GNU General Public
   License in all respects for all of the Red Hat elfutils code and other
   code used in conjunction with Red Hat elfutils except the Non-GPL Code
   covered by this exception.  If you modify this file, you may extend this
   exception to your version of the file, but you are not obligated to do
   so.  If you do not wish to provide this exception without modification,
   you must delete this exception statement from your version and license
   this file solely under the GPL without exception.

   Red Hat elfutils is an included package of the Open Invention Network.
   An included package of the Open Invention Network is a package for which
   Open Invention Network licensees cross-license their patents.  No patent
   license is granted, either expressly or impliedly, by designation as an
   included package.  Should you wish to participate in the Open Invention
   Network licensing program, please visit www.openinventionnetwork.com
   <http://www.openinventionnetwork.com>.  */

#ifndef _ELFUTILS_DWARF_OUTPUT
#define _ELFUTILS_DWARF_OUTPUT	1

#include "dwarf_edit"
#include <functional>

/* Read the comments for elfutils::dwarf first.

   The elfutils::dwarf_output class is template-compatible with the logical
   containers described in elfutils::dwarf and elfutils::dwarf_edit.

   The dwarf_output representation of the DWARF data is immutable once
   created.  The only way to create the object is by copy-construction
   from another compatible object: dwarf, dwarf_edit, or dwarf_output.
   Construction collects all the information necessary to generate the
   formatted DWARF sections.  */

namespace elfutils
{
  class dwarf_output_collector;

#if 0
  class dwarf_output
  {
  public:
    class compile_units;
    class debug_info_entry;
    typedef debug_info_entry compile_unit;

  private:
    template<typename input>
    static inline const input &
    collect (dwarf_output_collector &c,
	     const subr::auto_ref<const input> &p)
    {
      return static_cast<const input &> (p);
    }

    template<typename input>
    static inline const debug_info_entry &
    collect (dwarf_output_collector &,
	     const typename input::debug_info_entry &);

  public:

    // XXX later
    class attr_value : public dwarf::attr_value
    {
    public:
      attr_value (const dwarf::attr_value &v) : dwarf::attr_value (v) {}
    };

    class debug_info_entry
    {
      friend class dwarf_output;

    public:
      typedef subr::hashed_unordered_map<int, attr_value> attributes_type;
      typedef subr::hashed_vector<debug_info_entry> children_type;

    private:
      const int _m_tag;
      const attributes_type _m_attributes;
      const children_type _m_children;
      size_t _m_hash;

      /* The template constructor lets us copy in from any class that has
	 compatibly iterable containers for attributes and children.  */
      template<typename die_type>
      debug_info_entry (const die_type &die, dwarf_output_collector &c)
	: _m_tag (die.tag ()),
	  _m_attributes (die.attributes ()),
	  _m_children (die.children ()),
	  _m_hash (0)
      {
	subr::hash_combine (_m_hash, _m_tag);
	subr::hash_combine (_m_hash, _m_attributes);
	subr::hash_combine (_m_hash, _m_children);
      }

    public:
      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children.empty ();
      }

      inline const children_type &children () const
      {
	return _m_children;
      }

      inline const attributes_type &attributes () const
      {
	return _m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);
      }
    };

    typedef debug_info_entry::attributes_type::value_type attribute;

  public:
    /* Main container anchoring all the output.

       This is the only container that actually lives in the dwarf_output
       object.  All others live in the dwarf_output_collector's sets, and
       we return const references to those copies.

       This vector is actually mutable as a std::vector.  But note that you
       should never remove a compile_unit, though you can reorder the
       vector.  Nothing is ever removed from the collector, so your final
       output file can wind up with unreferenced data being encoded.  If
       you do remove any elements, then you should start a fresh collector
       and construct a new dwarf_output object by copying using that
       collector (or, equivalently, call o.compile_units ().recollect (C)
       on the new collector C).  */
    class compile_units
      : public std::vector<subr::auto_ref<const debug_info_entry> >
    {
      friend class dwarf_output;
    private:
      typedef std::vector<subr::auto_ref<const debug_info_entry> > _base;

      template<typename input>
      struct make
	: public std::binary_function<typename input::value_type,
				      dwarf_output_collector &,
				      _base::value_type>
      {
	_base::value_type operator () (const typename input::value_type &cu,
				       dwarf_output_collector &c) const
	{
	  return _base::value_type (collect (c, cu));
	}
      };

      // Construct empty container.
      compile_units ()
	: _base ()
      {}

      // Constructor copying CUs from input container.
      template<typename input>
      compile_units (const input &units, dwarf_output_collector &c)
	: _base ()
      {
	for (typename input::const_iterator it = units.begin ();
	     it != units.end ();
	     ++it)
	  push_back (make<input> () (*it, c));
      }

    public:
      template<typename other_children>
      bool operator== (const other_children &other) const
      {
	return subr::container_equal (*this, other);
      }
      template<typename other_children>
      bool operator!= (const other_children &other) const
      {
	return !(*this == other);
      }

      void recollect (dwarf_output_collector &c)
      {
	std::transform (begin (), end (), begin (),
			std::bind2nd (make<compile_units> (), c));
      }
    };

  private:
    const compile_units _m_units;

  public:
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  public:
    // Constructor for an empty file, can add to its compile_units ().
    dwarf_output ()
      : _m_units ()
    {}

    // Constructor copying CUs from an input file (can be any of dwarf,
    // dwarf_edit, or dwarf_output).
    template<typename input>
    dwarf_output (const input &dw, dwarf_output_collector &c)
      : _m_units (dw.compile_units (), c)
    {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

#else  // XXX temp

  class dwarf_output
  {
  public:
    typedef dwarf_data::source_file source_file;
    typedef dwarf_data::directory_table directory_table;
    typedef dwarf_data::line_entry<source_file> line_entry;
    typedef dwarf_data::line_table<line_entry> line_table;
    typedef dwarf_data::line_info_table<directory_table,
					line_table> line_info_table;
    typedef dwarf_data::dwarf_enum dwarf_enum;
    typedef dwarf_data::range_list range_list;
    typedef dwarf_data::location_attr location_attr;

    class compile_units;
    class debug_info_entry;

  protected:

    template<typename input>
    static inline const std::string &
    collect_string (dwarf_output_collector &c, const input &);

    /* An iterator adapter for use in iterator-based constructors.
       collectify (iterator) yields an iterator on input where *i
       constructs output::value_type (input::value_type v, collector).  */
    template<typename input, typename output>
    static inline typename subr::argifier<input, output,
					  dwarf_output_collector &>::result_type
    collectify (const typename input::const_iterator &in,
		dwarf_output_collector &c)
    {
      return subr::argifier<input, output, dwarf_output_collector &> (c) (in);
    }

    struct value_wrapper
      : public dwarf_data::value<dwarf_output>
    {
      struct value_string : public value_dispatch
      {
	const std::string &_m_str;

	template<typename string>
	inline value_string (const string &s, dwarf_output_collector &c)
	  : _m_str (collect_string (c, s))
	{}

	inline operator const std::string & () const
	{
	  return _m_str;
	}

	std::string to_string () const
	{
	  std::string result ("\"");
	  result += _m_str;
	  result += "\"";
	  return result;
	}
      };

      template<typename flavor, typename input>
      static inline value_dispatch *
      make (flavor *&, const input &, const subr::nothing &)
      {
	throw std::logic_error ("dwarf_output cannot be default-constructed");
      }

      template<typename flavor, typename input, typename arg_type>
      static inline value_dispatch *
      make (flavor *&result, const input &x, arg_type &arg)
      {
	return result = new flavor (x, arg);
      }

      template<typename input>
      static inline value_dispatch *
      make (value_string *&result, const input &x, dwarf_output_collector &c)
      {
	return result = new value_string (x, c);
      }

    };

  public:

    typedef dwarf_data::attr_value<dwarf_output, value_wrapper> attr_value;

    class debug_info_entry
    {
      friend class subr::create_container;

    public:
      typedef dwarf_data::attributes_type<dwarf_output,
					  value_wrapper> attributes_type;

      class children_type : public std::list<debug_info_entry>
      {
	friend class debug_info_entry;
      private:
        inline children_type () {}

	template<typename input, typename tracker>
	static inline void
	equivalence (const iterator &out,
		     const typename input::const_iterator &in, tracker &t)
	{
	  t.equivalence (out, in);
	}

	template<typename input, typename tracker>
	inline children_type (const input &other, tracker &t)
	{
	  subr::create_container (this, other, t, equivalence<input, tracker>);
	}

      public:
	typedef debug_info_entry value_type;

	inline iterator add_entry (int tag, const iterator &pos)
	{
	  return insert (pos, debug_info_entry (tag));
	}

	inline iterator add_entry (int tag)
	{
	  return add_entry (tag, end ());
	}
      };

      typedef children_type::iterator pointer;
      typedef children_type::const_iterator const_pointer;

    protected:
      int _m_tag;
      attributes_type _m_attributes;
      children_type _m_children;

      // This is can only be used by the children_type constructor,
      // which immediately calls set.
      inline debug_info_entry ()
	: _m_tag (-1), _m_attributes (), _m_children ()
      {}

      template<typename die_type, typename arg_type>
      inline void set (const die_type &die, arg_type &arg)
      {
	try
	  {
	    _m_tag = die.tag ();
	    _m_attributes.swap (attributes_type (die.attributes (), arg));
	    _m_children.swap (children_type (die.children (), arg));
	  }
	catch (...)
	  {
	    // Never leave a partially-formed DIE.
	    _m_tag = -1;
	    _m_attributes.clear ();
	    _m_children.clear ();
	    throw;
	  };
      }

    public:
      inline debug_info_entry (int t)
	: _m_tag (t), _m_attributes (), _m_children ()
      {
	if (unlikely (t <= 0))
	  throw std::invalid_argument ("invalid tag");
      }

      /* The template constructor lets us copy in from any class that has
	 compatibly iterable containers for attributes and children.  */
      template<typename die_type, typename tracker>
      debug_info_entry (const die_type &die, tracker &t)
	: _m_tag (die.tag ()),
	  _m_attributes (die.attributes (), t),
	  _m_children (die.children (), t)
      {}

      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children.empty ();
      }

      inline const children_type &children () const
      {
	return _m_children;
      }

      inline const attributes_type &attributes () const
      {
	return _m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.tag () == tag ()
		&& other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);;
      }

      inline ::Dwarf_Off identity () const
      {
	return (uintptr_t) this;
      }

      inline ::Dwarf_Off offset () const
      {
	return identity ();
      }
    };

    typedef debug_info_entry::attributes_type::value_type attribute;

    typedef dwarf_data::compile_unit<dwarf_output> compile_unit;

    // Main container anchoring all the output.
    class compile_units
      : public dwarf_data::compile_units<dwarf_output>
    {
      friend class dwarf_output;

    private:
      // Constructor copying CUs from input container.
      template<typename input, typename tracker>
      inline compile_units (const input &other, tracker &t)
	: dwarf_data::compile_units<dwarf_output> (other, t)
      {}

      inline compile_units (const compile_units &)
	: dwarf_data::compile_units<dwarf_output> ()
      {
	throw std::logic_error
	  ("must copy-construct top-level dwarf_output object instead");
      }

    public:
      // Default constructor: an empty container, no CUs.
      inline compile_units () {}
    };

  private:
    compile_units _m_units;

  public:
    class compile_units &compile_units ()
    {
      return _m_units;
    }
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  public:
    // Constructor for an empty file, can add to its compile_units ().
    inline dwarf_output () {}

    // Constructor copying CUs from an input file (can be any of dwarf,
    // dwarf_edit, or dwarf_output).
    template<typename input>
    inline dwarf_output (const input &dw, dwarf_output_collector &c)
      : _m_units (dw.compile_units (), c)
    {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

  // Explicit specializations.
  template<>
  std::string
  to_string<dwarf_output::attribute> (const dwarf_output::attribute &);
  template<>
  std::string
  to_string<dwarf_output::attr_value> (const dwarf_output::attr_value&);

#endif

  class dwarf_output_collector
  {
    friend class dwarf_output;

  private:
    subr::value_set<std::string> _m_strings;
    subr::value_set<dwarf_output::range_list> _m_ranges;

  public:

    template<typename die1, typename die2> // XXX
    inline void equivalence (const die1 &, const die2 &)
    {}

    template<typename die1, typename die2> // XXX
    inline void refer (die1 *, const die2 &)
    {}
  };

  template<typename input>
  inline const std::string &
  dwarf_output::collect_string (dwarf_output_collector &c, const input &s)
  {
    return c._m_strings.add (s);
  }

};

#endif	// <elfutils/dwarf_output>
