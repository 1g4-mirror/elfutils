/* elfutils::dwarf_output -- DWARF file generation in -*- C++ -*-
   Copyright (C) 2009 Red Hat, Inc.
   This file is part of Red Hat elfutils.

   Red Hat elfutils is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by the
   Free Software Foundation; version 2 of the License.

   Red Hat elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with Red Hat elfutils; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.

   In addition, as a special exception, Red Hat, Inc. gives You the
   additional right to link the code of Red Hat elfutils with code licensed
   under any Open Source Initiative certified open source license
   (http://www.opensource.org/licenses/index.php) which requires the
   distribution of source code with any binary distribution and to
   distribute linked combinations of the two.  Non-GPL Code permitted under
   this exception must only link to the code of Red Hat elfutils through
   those well defined interfaces identified in the file named EXCEPTION
   found in the source code files (the "Approved Interfaces").  The files
   of Non-GPL Code may instantiate templates or use macros or inline
   functions from the Approved Interfaces without causing the resulting
   work to be covered by the GNU General Public License.  Only Red Hat,
   Inc. may make changes or additions to the list of Approved Interfaces.
   Red Hat's grant of this exception is conditioned upon your not adding
   any new exceptions.  If you wish to add a new Approved Interface or
   exception, please contact Red Hat.  You must obey the GNU General Public
   License in all respects for all of the Red Hat elfutils code and other
   code used in conjunction with Red Hat elfutils except the Non-GPL Code
   covered by this exception.  If you modify this file, you may extend this
   exception to your version of the file, but you are not obligated to do
   so.  If you do not wish to provide this exception without modification,
   you must delete this exception statement from your version and license
   this file solely under the GPL without exception.

   Red Hat elfutils is an included package of the Open Invention Network.
   An included package of the Open Invention Network is a package for which
   Open Invention Network licensees cross-license their patents.  No patent
   license is granted, either expressly or impliedly, by designation as an
   included package.  Should you wish to participate in the Open Invention
   Network licensing program, please visit www.openinventionnetwork.com
   <http://www.openinventionnetwork.com>.  */

#ifndef _ELFUTILS_DWARF_OUTPUT
#define _ELFUTILS_DWARF_OUTPUT	1

#include "dwarf_edit"
#include "dwarf_ref_maker"
#include "dwarf_tracker"
#include <algorithm>
#include <functional>
#include <iterator>
#include <vector>
#include <tr1/unordered_set>

/* Read the comments for elfutils::dwarf first.

   The elfutils::dwarf_output class is template-compatible with the logical
   containers described in elfutils::dwarf and elfutils::dwarf_edit.

   The dwarf_output representation of the DWARF data is immutable once
   created.  The only way to create the object is by copy-construction
   from another compatible object: dwarf, dwarf_edit, or dwarf_output.
   Construction collects all the information necessary to generate the
   formatted DWARF sections.  */

namespace elfutils
{
  class dwarf_output_collector;

  class dwarf_output
  {
    friend class dwarf_output_collector;

  public:
    typedef dwarf_data::source_file source_file;
    typedef dwarf_data::directory_table directory_table;
    typedef dwarf_data::line_entry<source_file> line_entry;
    typedef dwarf_data::line_table<line_entry> line_table;
    typedef dwarf_data::line_info_table<directory_table,
					line_table> line_info_table;
    typedef dwarf_data::dwarf_enum dwarf_enum;
    typedef dwarf_data::range_list range_list;
    typedef dwarf_data::location_attr location_attr;

    class compile_units;
    class debug_info_entry;
    class attr_value;

  protected:
    static inline void never_copy ()
    {
      throw std::logic_error
	("must copy-construct top-level dwarf_output object instead");
    }

    template<typename input> class copier; // Below.
    template<typename input> class copier_step; // Below.

#if 0
    /* An iterator adapter for use in iterator-based constructors.
       collectify (iterator) yields an iterator on input where *i
       constructs output::value_type (input::value_type v, collector).  */
    template<typename input, typename output>
    static inline typename subr::argifier<input, output,
					  dwarf_output_collector &>::result_type
    collectify (const typename input::const_iterator &in,
		dwarf_output_collector &c)
    {
      return subr::argifier<input, output, dwarf_output_collector &> (c) (in);
    }
#endif

    /* Every kind of value is made by calling into the copier, which
       returns a const pointer into a value_set living in the collector.  */
    struct value
      : public dwarf_data::value<dwarf_output, false>
    {
      typedef const value_dispatch value_cell_type;

      typedef dwarf_data::value<dwarf_output> data;

      template<typename flavor, typename input>
      static inline value_dispatch *
      make (flavor *&, int, const input &, const subr::nothing &)
      {
	throw std::logic_error ("dwarf_output cannot be default-constructed");
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_string *&, int, const input &x, copier_step<input_dw> &c)
      {
	return c ().add_string (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_identifier *&, int, const input &x, copier_step<input_dw> &c)
      {
	return c ().add_identifier (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_reference *&, int, const input &x, copier_step<input_dw> &c)
      {
	return c.add_reference (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_flag *&, int, const input &x, copier_step<input_dw> &c)
      {
	return c ().add_flag (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_address *&, int, const input &x, copier_step<input_dw> &c)
      {
	return c ().add_address (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_rangelistptr *&, int, const input &x,
	    copier_step<input_dw> &c)
      {
	return c ().add_ranges (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_lineptr *&, int, const input &x, copier_step<input_dw> &c)
      {
	return c ().add_line_info (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_constant *&, int, const input &x, copier_step<input_dw> &c)
      {
	return c ().add_constant (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_constant_block *&, int, const input &x,
	    copier_step<input_dw> &c)
      {
	return c ().add_constant_block (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_dwarf_constant *&, int, const input &x,
	    copier_step<input_dw> &c)
      {
	return c ().add_dwarf_constant (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_file *&, int attr, const input &x,
	    copier_step<input_dw> &c)
      {
	return c ().add_source_file (attr, x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_line *&, int, const input &x,
	    copier_step<input_dw> &c)
      {
	return c ().add_source_line (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_column *&, int, const input &x,
	    copier_step<input_dw> &c)
      {
	return c ().add_source_column (x);
      }

      // XXX macptr

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_location *&, int, const input &x, copier_step<input_dw> &c)
      {
	return c ().add_location (x);
      }
    };

  public:

    class debug_info_entry
    {
      friend class dwarf_output;
      friend class dwarf_output_collector;

    public:
      class attributes_type
	: public dwarf_data::attributes_type<dwarf_output, value>
      {
	friend class debug_info_entry;

      private:
	typedef dwarf_data::attributes_type<dwarf_output, value> _base;

	size_t _m_hash;

	inline attributes_type ()
	  : _base (), _m_hash (0)
	{}

	struct same_attr : public std::equal_to<value_type>
	{
	  bool operator () (const value_type &a,
			    const value_type &b) const
	  {
	    return a.first == b.first && a.second.is (b.second);
	  }
	};

	inline void do_hash ()
	{
	  // Precompute our hash value based on our contents.
	  for (iterator i = begin (); i != end (); ++i)
	    subr::hash_combine (_m_hash, *i);
	}

	template<typename iter>
	inline attributes_type (const iter &from, const iter &to)
	  : _base (from, to), _m_hash (0)
	{
	  do_hash ();
	}

      public:
	friend class subr::hashed_hasher<attributes_type>;
	typedef subr::hashed_hasher<attributes_type> hasher;

	template<typename input, typename arg_type>
	inline attributes_type (const input &other, arg_type &c)
	  : _base (other, c), _m_hash (0)
	{
	  do_hash ();
	}

	inline bool is (const attributes_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (begin (), end (), these.begin (),
				 same_attr ()));
	}
      };

      class children_type
	: public std::vector<const debug_info_entry *>
      {
	friend class dwarf_output;

      protected:
	typedef std::vector<const debug_info_entry *> _base;

	size_t _m_hash;

        inline children_type () {}

	struct deref
	  : public std::unary_function<const debug_info_entry *,
				       const debug_info_entry &>
	{
	  inline deref (...) {}

	  inline const debug_info_entry &
	  operator () (const debug_info_entry *x) const
	  {
	    return *x;
	  }
	};

	inline void rehash ()
	{
	  _m_hash = rehasher () (*this);
	}

	inline const debug_info_entry **backpointer (size_t i)
	{
	  return &(_base::operator[] (i));
	}

      public:
	friend class subr::hashed_hasher<children_type>;
	typedef subr::hashed_hasher<children_type> hasher;
	typedef subr::container_hasher<children_type> rehasher;

	typedef debug_info_entry value_type;
	typedef debug_info_entry &reference;
	typedef debug_info_entry &const_reference;
	typedef debug_info_entry *pointer;
	typedef debug_info_entry *const_pointer;

	template<typename input, typename copier>
	inline children_type (const input &other, copier &c)
	  : _base (), _m_hash (0)
	{
	  typename input::const_iterator in = other.begin ();
	  bool has_sibling = in != other.end ();
	  while (has_sibling)
	    {
	      const typename input::const_iterator here = in++;
	      has_sibling = in != other.end ();
	      push_back (NULL);
	      _base::iterator out (--_base::end ());
	      const debug_info_entry *child = c.add_entry
		(out - _base::begin (), const_iterator (out, subr::nothing ()),
		 here, has_sibling);
	      *out = child;
	      subr::hash_combine (_m_hash, (uintptr_t) child);
	    }
	}

	inline bool is (const children_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (_base::begin (), _base::end (),
				 these._base::begin ()));
	}

	typedef subr::wrapped_input_iterator<
	  _base, deref, const debug_info_entry> const_iterator;
	typedef const_iterator iterator;

	inline const_iterator begin () const
	{
	  return const_iterator (_base::begin (), subr::nothing ());
	}

	inline const_iterator end () const
	{
	  return const_iterator (_base::end (), subr::nothing ());
	}
      };

      typedef children_type::iterator pointer;
      typedef children_type::const_iterator const_pointer;

    protected:
      value::value_reference _m_ref;
      const children_type *_m_children;
      const attributes_type *_m_attributes;
      void *_m_shape;
      size_t _m_hash;
      int _m_tag;

      // This is can only be used by the children_type constructor,
      // which immediately calls set.
      inline debug_info_entry ()
	: _m_children (NULL),
	  _m_attributes (NULL),
	  _m_shape (NULL),
	  _m_hash (0),
	  _m_tag (-1)
      {}

      inline debug_info_entry (int what,
			       const children_type *childs,
			       const attributes_type *attrs)
	: _m_ref (),		// XXX
	  _m_children (childs),
	  _m_attributes (attrs),
	  _m_shape (NULL),	// XXX
	  _m_tag (what)
      {
	set_hash ();
      }

      inline void set_hash ()
      {
	_m_hash = _m_tag;
	subr::hash_combine (_m_hash, *_m_attributes);
	subr::hash_combine (_m_hash, *_m_children);
      }

      template<typename input_die, typename copier_type,
	       typename attrs_dangle_type, typename children_dangle_type>
      inline debug_info_entry (const pointer &at,
			       const input_die &die,
			       copier_type &c,
			       attrs_dangle_type &attrs_dangle,
			       children_dangle_type &children_dangle)
	: _m_ref (at, subr::nothing ()),
	  _m_children (c.add_children (die.children (), &children_dangle)),
	  _m_attributes (c.add_attributes (die.attributes (), &attrs_dangle)),
	  _m_shape (NULL),	// XXX
	  _m_tag (die.tag ())
      {
	set_hash ();
      }

      template<typename die_type, typename copier_type>
      inline void set (const die_type &die, copier_type &c)
      {
	try
	  {
	    _m_tag = die.tag ();
	    _m_children = c.add_children (die.children (), NULL);
	    _m_attributes = c.add_attributes (die.attributes (), NULL);
	    set_hash ();
	  }
	catch (...)
	  {
	    // Never leave a partially-formed DIE.
	    _m_tag = -1;
	    _m_children = NULL;
	    _m_attributes = NULL;
	    throw;
	  };
      }

#if 0				// XXX
      template<typename input_die, typename copier_type>
      inline debug_info_entry (const pointer &at,
			       const input_die &die,
			       copier_type &c)
	: _m_ref (at, subr::nothing ()),
	  _m_children (c.add_children (die.children ())),
	  _m_attributes (c.add_attributes (die.attributes ())),
	  _m_shape (NULL),	// XXX
	  _m_tag (die.tag ())
      {
	set_hash ();
      }
#endif

    public:
      friend class subr::hashed_hasher<debug_info_entry>;
      typedef subr::hashed_hasher<debug_info_entry> hasher;

      inline bool is (const debug_info_entry &that) const
      {
	return (_m_hash == that._m_hash
		&& _m_tag == that._m_tag
		&& _m_attributes == that._m_attributes
		&& _m_children == that._m_children);
      }

      inline std::string to_string () const;

      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children->empty ();
      }

      inline const children_type &children () const
      {
	return *_m_children;
      }

      inline const attributes_type &attributes () const
      {
	return *_m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.tag () == tag ()
		&& other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);
      }

      inline ::Dwarf_Off identity () const
      {
	return (uintptr_t) this;
      }

      inline ::Dwarf_Off offset () const
      {
	return identity ();
      }
    };

    class attr_value
      : public dwarf_data::attr_value<dwarf_output, value>
    {
      friend class dwarf_output;

    private:
      typedef dwarf_data::attr_value<dwarf_output, value> _base;

    public:
      inline std::string to_string () const;

      /* These constructors can only be used by the containers
	 used in the collector.  The attributes_type map in an
	 actual debug_info_entry object is always const.  */
      inline attr_value ()
	: _base ()
      {}

      inline attr_value (const attr_value &other)
	: _base ()
      {
	this->_m_value = other._m_value;
      }

      /* Two identical values in fact share the same cell in the collector.
	 So we can use simple pointer comparison here.  */
      inline bool is (const attr_value &that) const
      {
	return this->_m_value == that._m_value;
      }

      // The is () test works only on a dwarf_output sharing the same collector.
      inline bool operator== (const attr_value &other) const
      {
	return is (other) || _base::operator== (other);
      }
      inline bool operator!= (const attr_value &other) const
      {
	return !(*this == other);
      }

      /* We can use the _m_value pointer itself as a perfect hash, because
	 all identical values share the same cell in the collector.  */
      struct hasher : public std::unary_function<attr_value, size_t>
      {
	inline size_t operator () (const attr_value &v) const
	{
	  return (uintptr_t) v._m_value;
	}
      };
    };

    typedef debug_info_entry::attributes_type::value_type attribute;

    typedef dwarf_data::compile_unit<dwarf_output> compile_unit;

    /* Main container anchoring all the output.

       This is the only container that actually lives in the dwarf_output
       object.  All others live in the dwarf_output_collector's sets, and
       we return const references to those copies.

       This list is actually mutable as a std::list.  But note that you
       should never remove a compile_unit, though you can reorder the
       list.  Nothing is ever removed from the collector, so your final
       output file can wind up with unreferenced data being encoded.  If
       you do remove any elements, then you should start a fresh collector
       and construct a new dwarf_output object by copying using that
       collector (or, equivalently, call o.compile_units ().recollect (C)
       on the new collector C).  */
    class compile_units
      : public dwarf_data::compile_units<dwarf_output>
    {
      friend class dwarf_output;

    private:
      inline compile_units (const compile_units &)
	: dwarf_data::compile_units<dwarf_output> ()
      {
	never_copy ();
      }

      template<typename input, typename copier_type>
      static inline void
      cu_maker (const iterator &out,
		const typename input::const_iterator &in,
		bool,	// last-sibling
		copier_type &c)
      {
	typename copier_type::tracker::walk into (c._m_tracker, in, out);
	out->set (*in, c);
	// t.equivalence (out, in);
      }

      // Constructor copying CUs from input container.
      template<typename input, typename tracker>
      inline compile_units (const input &other, tracker &t)
      {
	subr::create_container (this, other, t, cu_maker<input, tracker>);
      }

    public:
      // Default constructor: an empty container, no CUs.
      inline compile_units () {}
    };

  private:
    compile_units _m_units;

  public:
    class compile_units &compile_units ()
    {
      return _m_units;
    }
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  private:
    // Bind default copy-constructor and prevent it.
    inline dwarf_output (const dwarf_output &)
    {
      throw std::logic_error ("copying dwarf_output requires a collector");
    }

  public:
    // Constructor for an empty file, can add to its compile_units ().
    inline dwarf_output () {}

    // Constructor copying CUs from an input file (can be any of dwarf,
    // dwarf_edit, or dwarf_output).
    // Copy construction instantiates a copier derived from the collector.
    template<typename input>
    inline dwarf_output (const input &dw, dwarf_output_collector &c,
			 copier<input> maker = copier<input> ())
      : _m_units (dw.compile_units (), maker (c))
    {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

  // Explicit specializations.
  template<>
  std::string to_string<dwarf_output::debug_info_entry>
  (const dwarf_output::debug_info_entry &);
  inline std::string dwarf_output::debug_info_entry::to_string () const
  {
    return elfutils::to_string (*this); // Use that.
  }
  template<>
  std::string
  to_string<dwarf_output::attribute> (const dwarf_output::attribute &);
  template<>
  std::string
  to_string<dwarf_output::attr_value> (const dwarf_output::attr_value &);

  inline std::string dwarf_output::attr_value::to_string () const
  {
    return elfutils::to_string (*this); // Use that.
  }

  class dwarf_output_collector
  {
    friend class dwarf_output;

  private:
    dwarf_path_finder<dwarf_output> _m_tracker;
    unsigned int _m_total;

    typedef dwarf_output::debug_info_entry die_type;
    typedef die_type::attributes_type attrs_type;
    typedef die_type::children_type children_type;
    typedef children_type::const_iterator die_ptr;

    // Simple value sets for leaf types.
    subr::value_set<dwarf_output::value::value_string> _m_strings;
    subr::value_set<dwarf_output::value::value_identifier> _m_identifiers;
    subr::value_set<dwarf_output::value::value_address> _m_address;
    subr::value_set<dwarf_output::value::value_rangelistptr> _m_ranges;
    subr::value_set<dwarf_output::value::value_lineptr> _m_line_info;
    subr::value_set<dwarf_output::value::value_constant> _m_constants;
    subr::value_set<dwarf_output::value::value_constant_block> _m_const_block;
    subr::value_set<dwarf_output::value::value_dwarf_constant> _m_dwarf_const;
    subr::value_set<dwarf_output::value::value_source_file> _m_source_file;
    subr::value_set<dwarf_output::value::value_source_line> _m_source_line;
    subr::value_set<dwarf_output::value::value_source_column> _m_source_column;
    subr::value_set<dwarf_output::value::value_location> _m_locations;

    // The set of Boolean flags is a doubleton.
    static const dwarf_output::value::value_flag flag_true;
    static const dwarf_output::value::value_flag flag_false;
    static inline const dwarf_output::value::value_flag *flag (bool flag)
    {
      return flag ? &flag_true : &flag_false;
    }

    // Set of attribute maps.
    subr::identity_set<attrs_type> _m_attr_sets;

    inline const attrs_type *add (attrs_type &candidate)
    {
      return &*_m_attr_sets.insert (candidate).first;
    }

    // Set of children lists.
    subr::identity_set<children_type> _m_broods;

    inline const children_type *add (children_type &candidate)
    {
      return &*_m_broods.insert (candidate).first;
    }

    struct die_info
    {
      unsigned int uses;
      bool with_sibling;
      bool without_sibling;

      inline die_info ()
	: uses (0), with_sibling (false), without_sibling (false)
      {}
    };

    // Set of unique DIEs.
    typedef subr::identity_map<die_type, die_info> die_map;
    typedef die_map::value_type die_info_pair;
    die_map _m_unique;

    inline const die_type *add_entry (die_type &candidate, bool has_sibling)
    {
      std::pair <die_map::iterator, bool>
	ins = _m_unique.insert (std::make_pair (candidate, die_info ()));
      die_map::value_type &x = *ins.first;
      if (ins.second)
	{
	  assert (x.second.uses == 0);
	  if (has_sibling)
	    x.second.with_sibling = true;
	  else
	    x.second.without_sibling = true;
	  // XXX add_shape (x.first, !has_sibling);
	}
      x.second.uses++;
      ++_m_total;
      return &x.first;
    }

    struct shape_type
    {
      typedef std::vector<std::pair<int, int> > attrs_type;
      attrs_type _m_attrs;
      bool _m_has_children;
      size_t _m_hash;

      friend class subr::hashed_hasher<shape_type>;
      typedef subr::hashed_hasher<shape_type> hasher;

      inline void hashnadd (int name, int form);
      inline shape_type (const die_type &die, bool last_sibling);

      inline bool operator== (const shape_type &other) const
      {
	return (_m_hash == other._m_hash
		&& _m_has_children == other._m_has_children
		&& _m_attrs == other._m_attrs);
      }
      inline bool operator!= (const shape_type &other) const
      {
	return !(*this == other);
      }
    };

    typedef subr::nothing shape_info;

    typedef std::tr1::unordered_map<shape_type, shape_info,
				    shape_type::hasher> shape_map;
    shape_map _m_shapes;

    void add_shape (die_type &die, bool last_sibling);

  public:
    inline dwarf_output_collector ()
      : _m_total (0)
    {}

    static void die_stats (const die_map::value_type &elt)
    {
      std::cout << to_string (elt.first) << " uses="
		<< std::dec << elt.second.uses
		<< " (" << elt.second.with_sibling
		<< "," << elt.second.without_sibling << ")\n";
    }

    void stats () const
    {
      std::cout << "collected " << std::dec << _m_unique.size ()
		<< " unique of " << _m_total << " total DIEs\n";
      std::for_each (_m_unique.begin (), _m_unique.end (), die_stats);
    }
  };

  /* A copier_step object lives momentarily while building a
     constituent type.  It keeps track of whether the object
     built includes any dangling references.  */
  template<typename dw>
  class dwarf_output::copier_step
  {
    friend class copier<dw>;
  protected:
    typedef typename dw::debug_info_entry::children_type::const_iterator
    input_die_ptr;

    copier<dw> *_m_copier;
    bool _m_dangling;

    inline copier_step (copier<dw> *c)
      : _m_copier (c), _m_dangling (false)
    {}

  public:
    inline copier<dw> &operator () () const
    {
      return *_m_copier;
    }

    inline const value::value_dispatch *add_reference (const input_die_ptr &to)
    {
      return _m_copier->add_reference (to, _m_dangling);
    }

#if 0				// XXX
    template<typename input>
    inline const debug_info_entry::attributes_type *
    add_attributes (const input &other)
    {
      return _m_copier->add_attributes (other, _m_dangling);
    }

    template<typename input>
    inline const debug_info_entry::children_type *
    add_children (const input &other)
    {
      return _m_copier->add_children (other, _m_dangling);
    }
#endif
  };

  template<typename dw>
  class dwarf_output::copier
  {
    friend class dwarf_output;
  private:
    typedef typename dw::debug_info_entry::children_type::const_iterator
    input_die_ptr;

    struct tracker
      : public dwarf_tracker_base<dw, dwarf_output>
    {
      typedef dw dwarf1;
      typedef dwarf_output dwarf2;

      typedef dwarf_tracker_base<dwarf1, dwarf2> _base;

      explicit tracker (const tracker &)
	: _base ()
      {
	throw std::logic_error ("not copy-constructible");
      }

      typedef typename _base::cu1 cu1;
      typedef typename _base::cu2 cu2;
      typedef typename _base::die1 die1;
      typedef typename _base::die2 die2;
      typedef typename _base::dwarf1_ref dwarf1_ref;

      typedef dwarf_path_finder<dwarf1> tracker1;
      typedef dwarf_path_finder<dwarf2> tracker2;

      tracker1 _m_left;
      tracker2 _m_right;

      struct ref_hasher : public std::unary_function<die2, size_t>
      {
	inline size_t operator () (const die2 &i) const
	{
	  return i->identity ();
	}
      };

      struct same_ref : public std::equal_to<die2>
      {
	inline bool operator () (const die2 &a, const die2 &b) const
	{
	  return a->identity () == b->identity ();
	}
      };

      typedef std::pair<const die2 *,
			std::tr1::unordered_set<die2, ref_hasher, same_ref>
			> equiv_list;
      typedef std::tr1::unordered_map< ::Dwarf_Off, equiv_list> equiv_map;
      equiv_map *_m_equiv;
      bool _m_delete_equiv;

      inline equiv_list *equiv_to (const die1 &a)
      {
	return &(*_m_equiv)[a->identity ()];
      }

      /* Predicate for DIEs "equal enough" to match as context for a subtree.
	 The definition we use is that the DIE has the same tag and all its
	 attributes are equal, excepting that references in attribute values
	 are not compared.  */
      struct equal_enough : public std::binary_function<die1, die2, bool>
      {
	inline bool operator () (const die1 &a, const die2 &b)
	{
	  if (a->tag () != b->tag ())
	    return false;
	  dwarf_tracker_base<dwarf1, dwarf2> t;
	  return (dwarf_comparator<dwarf1, dwarf2, true> (t)
		  .equals (a->attributes (), b->attributes ()));
	}
      };

    public:
      inline tracker (const dwarf_output_collector &c)
	: _m_right (c._m_tracker, true),
	  _m_equiv (new equiv_map), _m_delete_equiv (true)
      {}


      inline tracker (const tracker &proto,
		      typename _base::reference_match &matched,
		      const typename _base::left_context_type &lhs,
		      const typename _base::die1 &a,
		      const typename _base::right_context_type &rhs,
		      const typename _base::die2 &b)
	: _base (proto, matched, lhs, a, b)
      {}


      struct walk
      {
	typename tracker1::walk _m_left;
	typename tracker2::walk _m_right;

	inline walk (tracker *w, const cu1 &a, const cu2 &b)
	  : _m_left (&w->_m_left, a), _m_right (&w->_m_right, b)
	{}
      };

      struct step
      {
	typename tracker1::step _m_left;
	typename tracker2::step _m_right;

	inline step (tracker *w, const die1 &a, const die2 &b)
	  : _m_left (&w->_m_left, a), _m_right (&w->_m_right, b)
	{}
      };

      typedef typename tracker1::die_path left_context_type;
      inline const left_context_type &left_context (const die1 &die)
      {
	return _m_left.path_to (die);
      }

      typedef typename tracker2::die_path right_context_type;
      inline const right_context_type &right_context (const die2 &die)
      {
	return _m_right.path_to (die);
      }

      // Very cheap check for an obvious mismatch of contexts.
      inline bool context_quick_mismatch (const left_context_type &a,
					  const right_context_type &b)

      {
	return a.size () != b.size ();
      }

      // Full match when context_quick_mismatch has returned false.
      inline bool context_match (const left_context_type &a,
				 const right_context_type &b)
      {
	return std::equal (a.begin (), a.end (), b.begin (), equal_enough ());
      }

      class reference_match
      {
	friend class tracker;
      private:
	equiv_list *_m_elt;

      public:

	inline reference_match ()
	  : _m_elt (NULL)
	{}

	inline ~reference_match ()
	{
	  if (_m_elt != NULL)
	    _m_elt->first = NULL;
	}

	inline bool cannot_match () const
	{
	  return _m_elt == NULL;
	}

	inline void notice_match (const die2 &b, bool matches) const
	{
	  if (matches && _m_elt != NULL)
	    _m_elt->second.insert (b);
	}
      };

      inline bool
      reference_matched (reference_match &matched, const die1 &a, const die2 &b)
      {
	equiv_list *elt = equiv_to (a);
	if (elt->first == NULL)
	  {
	    /* Record that we have a walk in progress crossing A.
	       When MATCHED goes out of scope in our caller, its
	       destructor will reset ELT->first to clear this record.  */
	    elt->first = &b;
	    matched._m_elt = elt;

	    // Short-circuit if we have already matched B to A.
	    return elt->second.find (b) != elt->second.end ();
	  }

	/* We have a circularity.  We can tell because ELT->first remains
	   set from an outer recursion still in progress.

	   The circular chain of references rooted at A matches B if B is
	   also the root of its own circularity and everything along those
	   parallel chains matches.  If the chains hadn't matched so far,
	   we would not have kept following them to get here.

	   We recorded the B that arrived at the first comparison with A.
	   We actually record the pointer on the caller's stack rather
	   than a copy of B, just because the iterator might be larger.  */

	return *elt->first == b;
      }

      // Share the _m_seen maps with the prototype tracker,
      // but start a fresh walk from the given starting point.
      inline tracker (const tracker &proto, reference_match &,
		      const left_context_type &lhs, const die1 &a,
		      const right_context_type &rhs, const die2 &b)
	: _m_left (proto._m_left, lhs, a),
	  _m_right (proto._m_right, rhs, b),
	  _m_equiv (proto._m_equiv), _m_delete_equiv (false)
      {
	// We are starting a recursive consideration of a vs b.
      }

      struct maker
      {
	equiv_list *_m_elt;

	inline maker ()
	  : _m_elt (NULL)
	{}

	inline const debug_info_entry *entry () const
	{
	  return &**_m_elt->second.begin ();
	}

	inline ~maker ()
	{
	  if (_m_elt != NULL)
	    _m_elt->first = NULL;
	}
      };

      inline bool already_made (maker &m, const typename _base::die1 &in,
				const debug_info_entry::pointer &at)
      {
	equiv_list *equiv = equiv_to (in);
	if (equiv->first == NULL)
	  {
	    /* Record that we have a walk in progress crossing A.
	       When M goes out of scope in our caller, its
	       destructor will reset ELT->first to clear this record.  */
	    equiv->first = &at;
	    m._m_elt = equiv;

	    return equiv->second.begin () != equiv->second.end ();
	  }

	throw std::logic_error("XXX circularity");
      }

    };

    dwarf_output_collector *_m_collector;
    tracker *_m_tracker;

    template<typename container_type> struct pending_container_info;

    struct pending_entry_info
    {
      /* These point to the fully-baked containers in the collector.
	 When both are set, then this entry is ready to be removed
	 from _m_pending_entries and baked in the collector.  */
      const debug_info_entry::attributes_type *_m_attributes;
      const debug_info_entry::children_type *_m_children;

      // Backpointers to _m_pending_children vectors that point to us.
      std::stack<std::pair<
		   const debug_info_entry **,
		   std::pair<debug_info_entry::children_type *const,
			     pending_container_info<debug_info_entry::children_type>
			     > *
		   > > _m_patch;

      inline
      pending_entry_info (const debug_info_entry::attributes_type *a = NULL,
			  const debug_info_entry::children_type *c = NULL)
	: _m_attributes (a), _m_children (c), _m_patch ()
      {}

      /* This entry is being baked, so replace all _m_pending_children
	 vectors' elements pointing to us with the final entry pointer.
	 First we update that vector's pointer in place.  Then we call
	 pending_container_info::resolve to count down until each such
	 children_type vector is ready to move into the collector.  */
      inline void resolve (copier *c, const debug_info_entry *final)
      {
	do
	  {
	    *_m_patch.top ().first = final;
	    _m_patch.top ().second->second.resolve
	      (c, _m_patch.top ().second->first);
	    _m_patch.pop ();
	  }
	while (!_m_patch.empty ());
      }
    };

    typedef subr::identity_map<debug_info_entry,
			       pending_entry_info> pending_entry_map;
    pending_entry_map _m_pending_entries;

    template<typename container_type>
    struct pending_container_info
    {
      typedef const typename pending_entry_map::value_type *backptr;
      std::stack<backptr> _m_patch;
      unsigned int _m_dangling;

      inline pending_container_info ()
	: _m_patch (), _m_dangling (0)
      {}

      bool resolve (copier *c, container_type *old)
      {
	if (--_m_dangling > 0)
	  // We still have other dangling refs.
	  return false;

	/* All these dangling refs have been filled.  Now we can
	   create a final container_type object in the collector.  */

	const container_type *final = c->_m_collector->add (*old);

	do
	  {
	    c->resolve_entry (_m_patch.top (), final);
	    _m_patch.pop ();
	  }
	while (!_m_patch.empty ());

	return true;
      }
    };

    template<typename container_type>
    struct pending_containers_map
      : public subr::identity_ptr_map<container_type,
				      pending_container_info<container_type> >
    {
    };

    typedef pending_containers_map<debug_info_entry::attributes_type
				   > pending_attrs_map;
    typedef typename pending_attrs_map::mapped_type pending_attrs_info;
    pending_attrs_map _m_pending_attr_sets;

    /* This is called each time one dangling reference is resolved.
       When the number still dangling in an attributes_type reaches
       zero, then it can be reified in the collector.  */
    void resolve_pending_attrs (typename pending_attrs_map::value_type *p)
    {
      if (p->second.resolve (this, &p->first))
	_m_pending_attr_sets.erase (p->first);
    }

    typedef pending_containers_map<debug_info_entry::children_type
				   > pending_children_map;
    typedef typename pending_children_map::mapped_type pending_children_info;
    pending_children_map _m_pending_children;

    inline copier ()
      : _m_collector (NULL), _m_tracker (NULL),
	_m_pending_entries (),
	_m_pending_attr_sets (),
	_m_pending_children ()
    {}

    inline ~copier ()
    {
      if (_m_tracker != NULL)
	delete _m_tracker;
    }

    copier &operator () (dwarf_output_collector &c)
    {
      _m_collector = &c;
      assert (_m_tracker == NULL);
      _m_tracker = new tracker (c);
      return *this;
    }

    inline operator dwarf_output_collector & ()
    {
      return *_m_collector;
    }

    template<typename input>
    inline const value::value_string *add_string (const input &x)
    {
      return _m_collector->_m_strings.add (x);
    }

    template<typename input>
    inline const value::value_string *add_identifier (const input &x)
    {
      return _m_collector->_m_identifiers.add (x);
    }

    template<typename input>
    inline const value::value_flag *add_flag (const input &x)
    {
      return dwarf_output_collector::flag (x);
    }

    template<typename input>
    inline const value::value_address *add_address (const input &x)
    {
      return _m_collector->_m_address.add (x);
    }

    template<typename input>
    inline const value::value_rangelistptr *add_ranges (const input &x)
    {
      return _m_collector->_m_ranges.add (x);
    }

    template<typename input>
    inline const value::value_lineptr *add_line_info (const input &x)
    {
      return _m_collector->_m_line_info.add (x, *_m_collector);
    }

    template<typename input>
    inline const value::value_constant *add_constant (const input &x)
    {
      return _m_collector->_m_constants.add (x);
    }

    template<typename input>
    inline const value::value_constant_block *
    add_constant_block (const input &x)
    {
      return _m_collector->_m_const_block.add (x);
    }

    template<typename input>
    inline const value::value_dwarf_constant *
    add_dwarf_constant (const input &x)
    {
      return _m_collector->_m_dwarf_const.add (x);
    }

    template<typename input>
    inline const value::value_source_file *add_source_file (int /*whatattr*/,
							    const input &x)
    {
      return _m_collector->_m_source_file.add (x);
    }

    template<typename input>
    inline const value::value_source_line *add_source_line (const input &x)
    {
      return _m_collector->_m_source_line.add (x);
    }

    template<typename input>
    inline const value::value_source_column *add_source_column (const input &x)
    {
      return _m_collector->_m_source_column.add (x);
    }

    template<typename input>
    inline const value::value_location *add_location (const input &x)
    {
      return _m_collector->_m_locations.add (x);
    }

    struct attrs_copier : public copier_step<dw>
    {
      debug_info_entry::attributes_type *_m_candidate;

      template<typename input>
      explicit inline attrs_copier (const input &x, copier *c)
	: copier_step<dw> (c)
      {
	_m_candidate = new debug_info_entry::attributes_type (x, *this);
      }

      inline ~attrs_copier ()
      {
	if (_m_candidate != NULL)
	  delete _m_candidate;
      }
    };

    template<typename input>
    inline const debug_info_entry::attributes_type *
    add_attributes (const input &x, pending_attrs_info **dangling)
    {
      // Construct a candidate attributes_type map.
      attrs_copier c (x, this);

      if (!c._m_dangling)
	// No dangling references.  Put it into the collector right here.
	return _m_collector->add (*c._m_candidate);

      if (unlikely (dangling == NULL))
	throw std::logic_error ("compile_unit has dangling references");

      /* We have some dangling references, so this has to
	 go into the copier's pending set instead.  */
      std::pair<typename pending_attrs_map::iterator, bool> p
	= _m_pending_attr_sets.insert (std::make_pair (c._m_candidate,
						       pending_attrs_info ()));
      if (p.second)
	{
	  /* This is a new entry in the pending set.
	     All its dangling references need their backpointers set up.  */
	  assert (p.first->first == c._m_candidate);
	  c._m_candidate = NULL;
	  std::for_each (p.first->first->begin (), p.first->first->end (),
			 record_dangling_reference (p.first));
	}
      else
	assert (p.first->second._m_dangling > 0);
      *dangling = &p.first->second;
      return p.first->first;
    }

    struct children_copier : public copier_step<dw>
    {
      std::stack<std::pair<size_t, pending_entry_info *> > _m_pending;
      debug_info_entry::children_type *_m_candidate;

      template<typename input>
      explicit inline children_copier (const input &x, copier *c)
	: copier_step<dw> (c),
	  _m_pending ()
      {
	_m_candidate = new debug_info_entry::children_type (x, *this);
      }

      inline ~children_copier ()
      {
	if (_m_candidate != NULL)
	  delete _m_candidate;
      }

      /* This is called by the children_type copy-constructor from
	 inside add_children, below.  */
      inline const debug_info_entry *
      add_entry (size_t i, const debug_info_entry::children_type::iterator &at,
		 const input_die_ptr &other, bool has_sibling)
      {
	return this->_m_copier->add_entry (i, at, other, has_sibling, this);
      }

      /* When add_entry is returning a pending_entry pointer,
	 it calls this first.  */
      inline void record_child (size_t i, pending_entry_info *entry)
      {
	this->_m_dangling = true;
	_m_pending.push (std::make_pair (i, entry));
      }

      /* If this children_type containing pending entries and was new
	 in _m_pending_children, then we get here.  Now we can give each
	 pending_entry_info its back-pointer to us.  */
      inline void reify (typename pending_children_map::value_type &v)
      {
	assert (v.first == _m_candidate);
	_m_candidate = NULL;
	do
	  {
	    const size_t i = _m_pending.top ().first;
	    pending_entry_info *const entry = _m_pending.top ().second;
	    entry->_m_patch.push
	      (std::make_pair (v.first->backpointer (i), &v));
	    _m_pending.pop ();
	  }
	while (!_m_pending.empty ());
      }
    };

    template<typename input>
    inline const debug_info_entry::children_type *
    add_children (const input &x, pending_children_info **dangling)
    {
      // Construct a candidate children_type vector.
      children_copier c (x, this);

      if (!c._m_dangling)
	// No dangling references.  Put it into the collector right here.
	return _m_collector->add (*c._m_candidate);

      if (unlikely (dangling == NULL))
	throw std::logic_error ("XXX compile_unit has dangling children");

      /* We have some dangling references, so this has to
	 go into the copier's pending set instead.  */
      std::pair<typename pending_children_map::iterator, bool> p
	= (_m_pending_children.insert
	   (std::make_pair (c._m_candidate, pending_children_info ())));
      if (p.second)
	/* This is a new entry in the pending set.
	   All its dangling references need their backpointers set up.  */
	c.reify (*p.first);
      else
	assert (p.first->second._m_dangling > 0);
      *dangling = &p.first->second;
      return p.first->first;
    }

    inline const debug_info_entry *
    add_entry (size_t i, const debug_info_entry::children_type::iterator &at,
	       const input_die_ptr &in, bool has_sibling,
	       children_copier *step)
    {
      typename tracker::maker m;
      if (_m_tracker->already_made (m, in, at))
	return m.entry ();

      typename tracker::step into (_m_tracker, in, at);

      pending_attrs_info *attr_dangle = NULL;
      pending_children_info *child_dangle = NULL;

      debug_info_entry candidate (at, *in, *this, attr_dangle, child_dangle);

      if (attr_dangle == NULL && child_dangle == NULL)
	{
	  // No dangling refs, create it in the collector.
	  const debug_info_entry *die = _m_collector->add_entry (candidate,
								 has_sibling);
	  m._m_elt->second.insert (die->_m_ref.ref);
	  return die;
	}

      /* We have some dangling references in our attributes or children.
	 This goes into the pending set until those are resolved.  */

      std::pair<typename pending_entry_map::iterator, bool> p
	= _m_pending_entries.insert (std::make_pair (candidate,
						     pending_entry_info ()));
      typename pending_entry_map::value_type &v = *p.first;
      if (p.second)
	{
	  // This is a new entry.  It needs backpointers set up.

	  if (attr_dangle == NULL)
	    // Our attributes are already final.
	    v.second._m_attributes = v.first._m_attributes;
	  else
	    // Give our pending attributes a backpointer to update us.
	    attr_dangle->_m_patch.push (&v);

	  if (child_dangle == NULL)
	    // Our children are already final.
	    v.second._m_children = v.first._m_children;
	  else
	    // Give our pending children vector a backpointer to update us.
	    child_dangle->_m_patch.push (&v);
	}

      step->record_child (i, &v.second);

      return &v.first;
    }

    /* An attr_value that is a dangling reference to a DIE not yet
       built in the output has one of these in place of a value_reference.
       These all live in the _m_dangling map, one per input-side DIE.  */
    struct reference_patch;
    struct dangling_reference
      : public value::value_dispatch
    {
      reference_patch *_m_patch;

      inline dangling_reference ()
	: _m_patch (new reference_patch)
      {
      }

      inline ~dangling_reference ()
      {
	delete _m_patch;
      }
    };

    typedef std::tr1::unordered_map< ::Dwarf_Off,
				     dangling_reference> dangling_map;
    dangling_map _m_dangling;

    inline const value::value_dispatch *
    add_reference (const input_die_ptr &to, bool &dangling)
    {
      // Short-circuit if we have already copied TO.
      typename tracker::maker m;
      debug_info_entry::pointer at; // XXX
      if (_m_tracker->already_made (m, to, at))
	return &m.entry ()->_m_ref;

      /* Our copying walk has not reached this DIE yet, so this is a
	 forward reference.  Record it.  */
      dangling = true;
      return &_m_dangling[to->identity ()];
    }

    /* This object holds the guts of each dangling reference.  It's
       separate from dangling_reference only because of const issues.

       Here we record back-pointers to the attributes_type objects (living
       in _m_pending_attr_sets) that point to us.  Each time we record one,
       we increment its count in the _m_pending_attr_sets map.
    */
    struct reference_patch
    {
      std::stack<std::pair<typename pending_attrs_map::value_type *,
			   attr_value *>
		 > _m_patch;
      debug_info_entry::pointer _m_ref;

      inline reference_patch ()
	: _m_patch ()
      {
      }

      inline void used_at (typename pending_attrs_map::value_type *p,
			   attr_value *v)
      {
	_m_patch.push (std::make_pair (p, v));
	++p->second._m_dangling;
      }

      inline void resolve (const debug_info_entry::pointer &ref, copier *c)
      {
	while (!_m_patch.empty ())
	  {
	    _m_patch.top ().second->_m_value = &ref->_m_ref;
	    c->resolve_pending_attrs (_m_patch.top ().first);
	    _m_patch.pop ();
	  }
      }
    };

    /* This gets called after add_reference if the containing
       attributes_type is being freshly recorded in _m_pending_attr_sets.  */
    struct record_dangling_reference
      : public std::unary_function<const attribute &, void>
    {
      const typename pending_attrs_map::iterator &_m_i;
      inline record_dangling_reference
      (const typename pending_attrs_map::iterator &i)
	: _m_i (i)
      {}

      inline void operator () (attribute &attr) const
      {
	const dangling_reference *ref
	  = dynamic_cast<const dangling_reference *> (attr.second._m_value);
	if (ref != NULL)
	  ref->_m_patch->used_at (&*_m_i, &attr.second);
      }
    };

    inline void
    resolve_dangling_references (const input_die_ptr &in,
				 const debug_info_entry::pointer &out)
    {
      typename dangling_map::iterator i = _m_dangling.find (in->identity ());
      if (i != _m_dangling.end ())
	{
	  i->second._m_patch->resolve (out, this);
	  _m_dangling.erase (i);
	}
    }

    // Partially resolve a pending entry with final attributes.
    inline void resolve_entry (typename pending_entry_map::value_type *p,
			       const debug_info_entry::attributes_type *attrs)
    {
      p->second._m_attributes = attrs;
      if (p->second._m_children != NULL)
	resolve_entry (p);
    }

    // Partially resolve a pending entry with final children.
    inline void resolve_entry (typename pending_entry_map::value_type *p,
			       const debug_info_entry::children_type *children)
    {
      p->second._m_children = children;
      if (p->second._m_attributes != NULL)
	resolve_entry (p);
    }

    /* When a pending entry's attributes and children are both resolved,
       we can move it into the collector.  */
    inline void resolve_entry (typename pending_entry_map::value_type *p)
    {
      // This back-patches all the pointers to the old pending entry.
      p->second.resolve (this,
			 _m_collector->add_entry
			 (debug_info_entry (p->first._m_tag,
					    p->second._m_children,
					    p->second._m_attributes),
			  false)); //XXX has_sibling

      /* XXX if it is safe to keep an unordered_map::iterator across other
	 additions/removals to the map, then we could store that in
	 pending_container_info instead, but I'm not sure that it is,
	 though apparently keeping the value_type (pair) pointer is safe.
	 So we are searching the map again passing the key_type pointer
	 stored in the map itself, just to erase it.  */
      _m_pending_entries.erase (p->first);
    }
  };
};

#endif	// <elfutils/dwarf_output>
