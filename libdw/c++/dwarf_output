/* elfutils::dwarf_output -- DWARF file generation in -*- C++ -*-
   Copyright (C) 2009 Red Hat, Inc.
   This file is part of Red Hat elfutils.

   Red Hat elfutils is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by the
   Free Software Foundation; version 2 of the License.

   Red Hat elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with Red Hat elfutils; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.

   In addition, as a special exception, Red Hat, Inc. gives You the
   additional right to link the code of Red Hat elfutils with code licensed
   under any Open Source Initiative certified open source license
   (http://www.opensource.org/licenses/index.php) which requires the
   distribution of source code with any binary distribution and to
   distribute linked combinations of the two.  Non-GPL Code permitted under
   this exception must only link to the code of Red Hat elfutils through
   those well defined interfaces identified in the file named EXCEPTION
   found in the source code files (the "Approved Interfaces").  The files
   of Non-GPL Code may instantiate templates or use macros or inline
   functions from the Approved Interfaces without causing the resulting
   work to be covered by the GNU General Public License.  Only Red Hat,
   Inc. may make changes or additions to the list of Approved Interfaces.
   Red Hat's grant of this exception is conditioned upon your not adding
   any new exceptions.  If you wish to add a new Approved Interface or
   exception, please contact Red Hat.  You must obey the GNU General Public
   License in all respects for all of the Red Hat elfutils code and other
   code used in conjunction with Red Hat elfutils except the Non-GPL Code
   covered by this exception.  If you modify this file, you may extend this
   exception to your version of the file, but you are not obligated to do
   so.  If you do not wish to provide this exception without modification,
   you must delete this exception statement from your version and license
   this file solely under the GPL without exception.

   Red Hat elfutils is an included package of the Open Invention Network.
   An included package of the Open Invention Network is a package for which
   Open Invention Network licensees cross-license their patents.  No patent
   license is granted, either expressly or impliedly, by designation as an
   included package.  Should you wish to participate in the Open Invention
   Network licensing program, please visit www.openinventionnetwork.com
   <http://www.openinventionnetwork.com>.  */

#ifndef _ELFUTILS_DWARF_OUTPUT
#define _ELFUTILS_DWARF_OUTPUT	1

#include "dwarf_edit"
#include "dwarf_ref_maker"
#include "dwarf_tracker"
#include <algorithm>
#include <functional>
#include <iterator>
#include <vector>
#include <tr1/unordered_set>

extern "C" {
#include "../libebl/libebl.h" // XXX
}

/* Read the comments for elfutils::dwarf first.

   The elfutils::dwarf_output class is template-compatible with the logical
   containers described in elfutils::dwarf and elfutils::dwarf_edit.

   The dwarf_output representation of the DWARF data is immutable once
   created.  The only way to create the object is by copy-construction
   from another compatible object: dwarf, dwarf_edit, or dwarf_output.
   Construction collects all the information necessary to generate the
   formatted DWARF sections.  */

namespace elfutils
{
  class dwarf_output_collector;

  class section_appender
  {
    Elf_Data *_m_data;
    size_t const _m_alloc_unit;
    Elf_Scn *const _m_scn;
    size_t _m_totsize;

    inline void more ()
    {
      _m_data = elf_newdata (_m_scn);
      if (_m_data == NULL)
	throw std::runtime_error (std::string ("Error while creating section data: ")
				  + elf_errmsg (-1));
      // xxx free on failure

      _m_data->d_buf = (void *) new unsigned char[_m_alloc_unit];
      _m_data->d_type = ELF_T_BYTE;
      _m_data->d_align = 1;
      _m_data->d_size = 0;
    }

  public:
    typedef unsigned char value_type;
    typedef value_type const &const_reference;

    section_appender (Elf_Scn *scn, size_t alloc_unit)
      : _m_alloc_unit (alloc_unit)
      , _m_scn (scn)
      , _m_totsize (0)
    {
      more ();
    }

    unsigned char *alloc(size_t a_size)
    {
      size_t ns = _m_data->d_size + a_size;
      if (ns > _m_alloc_unit)
	{
	  more ();
	  ns = a_size;
	}

      unsigned char *ptr = (unsigned char *) _m_data->d_buf + _m_data->d_size;
      _m_data->d_size = ns;
      _m_totsize += a_size;

      return ptr;
    }

    void push_back (unsigned char byte)
    {
      *alloc (1) = byte;
    }

    ::Dwarf_Off size () const
    {
      return _m_totsize;
    }
  };

  struct strtab
  {
    explicit strtab (bool nullstr)
      : _m_strtab (ebl_strtabinit (nullstr))
    {
      if (_m_strtab == NULL)
	throw std::runtime_error ("Couldn't initialize strtab.");
    }

    ~strtab ()
    {
      ebl_strtabfree (_m_strtab);
    }

    Elf_Data *finalize (Elf_Scn *scn)
    {
      Elf_Data *data = elf_newdata (scn);
      // xxx free on failure
      if (data == NULL)
	throw std::runtime_error ("Couldn't create data for strtab.");
      ebl_strtabfinalize (_m_strtab, data);
      return data;
    }

    Ebl_Strent *add (char const *str)
    {
      return ebl_strtabadd (_m_strtab, str, 0);
    }

  private:
    Ebl_Strtab *_m_strtab;
  };

  class dwarf_output
  {
    friend class dwarf_output_collector;

  public:
    typedef dwarf_data::source_file source_file;
    typedef dwarf_data::directory_table directory_table;
    typedef dwarf_data::line_entry<source_file> line_entry;
    typedef dwarf_data::line_table<line_entry> line_table;
    typedef dwarf_data::line_info_table<directory_table,
					line_table> line_info_table;
    typedef dwarf_data::dwarf_enum dwarf_enum;
    typedef dwarf_data::range_list range_list;
    typedef dwarf_data::location_attr location_attr;

    class compile_units;
    class debug_info_entry;
    class attr_value;

  protected:
    static inline void never_copy ()
    {
      throw std::logic_error
	("must copy-construct top-level dwarf_output object instead");
    }

    template<typename input> class copier; // Below.

#if 0
    /* An iterator adapter for use in iterator-based constructors.
       collectify (iterator) yields an iterator on input where *i
       constructs output::value_type (input::value_type v, collector).  */
    template<typename input, typename output>
    static inline typename subr::argifier<input, output,
					  dwarf_output_collector &>::result_type
    collectify (const typename input::const_iterator &in,
		dwarf_output_collector &c)
    {
      return subr::argifier<input, output, dwarf_output_collector &> (c) (in);
    }
#endif

    /* Every kind of value is made by calling into the copier, which
       returns a const pointer into a value_set living in the collector.  */
    struct value
      : public dwarf_data::value<dwarf_output, false>
    {
      typedef const value_dispatch value_cell_type;

      typedef dwarf_data::value<dwarf_output> data;

      template<typename flavor, typename input>
      static inline value_dispatch *
      make (flavor *&, int, const input &, const subr::nothing &)
      {
	throw std::logic_error ("dwarf_output cannot be default-constructed");
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_string *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_string (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_identifier *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_identifier (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_reference *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_reference (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_flag *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_flag (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_address *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_address (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_rangelistptr *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_ranges (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_lineptr *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_line_info (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_constant *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_constant (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_constant_block *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_constant_block (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_dwarf_constant *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_dwarf_constant (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_file *&, int attr, const input &x, copier<input_dw> &c)
      {
	return c.add_source_file (attr, x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_line *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_source_line (x);
      }

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_source_column *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_source_column (x);
      }

      // XXX macptr

      template<typename input, typename input_dw>
      static inline const value_dispatch *
      make (value_location *&, int, const input &x, copier<input_dw> &c)
      {
	return c.add_location (x);
      }
    };

  public:

    class debug_info_entry
    {
      friend class dwarf_output;
      friend class dwarf_output_collector;

    public:
      class attributes_type
	: public dwarf_data::attributes_type<dwarf_output, value>
      {
	friend class debug_info_entry;

      private:
	typedef dwarf_data::attributes_type<dwarf_output, value> _base;

	size_t _m_hash;

	inline attributes_type ()
	  : _base (), _m_hash (0)
	{}

	struct same_attr : public std::equal_to<value_type>
	{
	  bool operator () (const value_type &a,
			    const value_type &b) const
	  {
	    return a.first == b.first && a.second.is (b.second);
	  }
	};

      public:
	friend class subr::hashed_hasher<attributes_type>;
	typedef subr::hashed_hasher<attributes_type> hasher;

	template<typename input, typename arg_type>
	inline attributes_type (const input &other, arg_type &c)
	  : _base (other, c), _m_hash (0)
	{
	  // Precompute our hash value based on our contents.
	  for (iterator i = begin (); i != end (); ++i)
	    subr::hash_combine (_m_hash, *i);
	}

	inline bool is (const attributes_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (begin (), end (), these.begin (),
				 same_attr ()));
	}
      };

      class children_type
	: public std::vector<const debug_info_entry *>
      {
	friend class debug_info_entry;
      protected:
	typedef std::vector<const debug_info_entry *> _base;

	size_t _m_hash;

        inline children_type () {}

	struct deref
	  : public std::unary_function<const debug_info_entry *,
				       const debug_info_entry &>
	{
	  inline deref (...) {}

	  inline const debug_info_entry &
	  operator () (const debug_info_entry *x) const
	  {
	    return *x;
	  }
	};

      public:
	friend class subr::hashed_hasher<children_type>;
	typedef subr::hashed_hasher<children_type> hasher;

	typedef debug_info_entry value_type;
	typedef debug_info_entry &reference;
	typedef debug_info_entry &const_reference;
	typedef debug_info_entry *pointer;
	typedef debug_info_entry *const_pointer;

	template<typename input, typename copier>
	inline children_type (const input &other, copier &c)
	  : _base (), _m_hash (0)
	{
	  /* XXX hack.  We use vector iterators as die references.
	     push_back potentially invalidates these iterators.  Work
	     around that by reserving vector big enough to hold all
	     the children, so that realloc & invalidation of these
	     iterators doesn't occur.  */
	  size_t count = 0;
	  for (typename input::const_iterator in = other.begin ();
	       in != other.end (); ++in)
	    ++count;
	  reserve (count);

	  typename input::const_iterator in = other.begin ();
	  bool has_sibling = in != other.end ();
	  while (has_sibling)
	    {
	      const typename input::const_iterator here = in++;
	      has_sibling = in != other.end ();
	      const debug_info_entry *child = c.add_entry (*here, has_sibling);
	      subr::hash_combine (_m_hash, (uintptr_t) child);
	      push_back (child);
	      c.copied (--end (), here, has_sibling);
	    }
	}

	inline bool is (const children_type &these) const
	{
	  return (_m_hash == these._m_hash
		  && size () == these.size ()
		  && std::equal (_base::begin (), _base::end (),
				 these._base::begin ()));
	}

	typedef subr::wrapped_input_iterator<
	  _base, deref, const debug_info_entry> const_iterator;
	typedef const_iterator iterator;

	inline const_iterator begin () const
	{
	  return const_iterator (_base::begin (), subr::nothing ());
	}

	inline const_iterator end () const
	{
	  return const_iterator (_base::end (), subr::nothing ());
	}
      };

      typedef children_type::iterator pointer;
      typedef children_type::const_iterator const_pointer;

    protected:
      const children_type *_m_children;
      const attributes_type *_m_attributes;
      size_t _m_hash;
      int _m_tag;

      // This is can only be used by the children_type constructor,
      // which immediately calls set.
      inline debug_info_entry ()
	: _m_children (NULL),
	  _m_attributes (NULL),
	  _m_hash (0),
	  _m_tag (-1)
      {}

      template<typename die_type, typename input_dw>
      inline debug_info_entry (const die_type &die, copier<input_dw> &c)
	: _m_children (c.add_children (die.children ())),
	  _m_attributes (c.add_attributes (die.attributes ())),
	  _m_hash (die.tag ()),
	  _m_tag (die.tag ())
      {
	subr::hash_combine (_m_hash, *_m_attributes);
	subr::hash_combine (_m_hash, *_m_children);
      }

    public:
      friend class subr::hashed_hasher<debug_info_entry>;
      typedef subr::hashed_hasher<debug_info_entry> hasher;

      inline bool is (const debug_info_entry &that) const
      {
	return (_m_hash == that._m_hash
		&& _m_tag == that._m_tag
		&& _m_attributes == that._m_attributes
		&& _m_children == that._m_children);
      }

      inline std::string to_string () const;

      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children->empty ();
      }

      inline const children_type &children () const
      {
	return *_m_children;
      }

      inline const attributes_type &attributes () const
      {
	return *_m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.tag () == tag ()
		&& other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);
      }

      inline ::Dwarf_Off identity () const
      {
	return (uintptr_t) this;
      }

      inline ::Dwarf_Off offset () const
      {
	return identity ();
      }
    };

    class attr_value
      : public dwarf_data::attr_value<dwarf_output, value>
    {
    private:
      typedef dwarf_data::attr_value<dwarf_output, value> _base;

    public:
      inline std::string to_string () const;

      /* These constructors can only be used by the containers
	 used in the collector.  The attributes_type map in an
	 actual debug_info_entry object is always const.  */
      inline attr_value ()
	: _base ()
      {}

      inline attr_value (const attr_value &other)
	: _base ()
      {
	this->_m_value = other._m_value;
      }

      /* Two identical values in fact share the same cell in the collector.
	 So we can use simple pointer comparison here.  */
      inline bool is (const attr_value &that) const
      {
	return this->_m_value == that._m_value;
      }

      // The is () test works only on a dwarf_output sharing the same collector.
      inline bool operator== (const attr_value &other) const
      {
	return is (other) || _base::operator== (other);
      }
      inline bool operator!= (const attr_value &other) const
      {
	return !(*this == other);
      }

      /* We can use the _m_value pointer itself as a perfect hash, because
	 all identical values share the same cell in the collector.  */
      struct hasher : public std::unary_function<attr_value, size_t>
      {
	inline size_t operator () (const attr_value &v) const
	{
	  return (uintptr_t) v._m_value;
	}
      };
    };

    typedef debug_info_entry::attributes_type::value_type attribute;

    class compile_unit
      : public dwarf_data::compile_unit<dwarf_output>
    {
      typedef dwarf_data::compile_unit<dwarf_output> _base;
    public:
      debug_info_entry const *const _m_cu_die;

      compile_unit ()
	: _m_cu_die (NULL)
      {}

      compile_unit (compile_unit const &copy)
	: _base (copy)
	, _m_cu_die (copy._m_cu_die) // XXX?
      {}

      template<typename input, typename arg_type>
      inline compile_unit (const input &cu, arg_type &arg)
	: _base (cu, arg)
	, _m_cu_die (arg.add_entry_2 (*this, false))
      {
	std::cout << "CU ctor " << to_string () << std::endl;
      }
    };

    /* Main container anchoring all the output.

       This is the only container that actually lives in the dwarf_output
       object.  All others live in the dwarf_output_collector's sets, and
       we return const references to those copies.

       This list is actually mutable as a std::list.  But note that you
       should never remove a compile_unit, though you can reorder the
       list.  Nothing is ever removed from the collector, so your final
       output file can wind up with unreferenced data being encoded.  If
       you do remove any elements, then you should start a fresh collector
       and construct a new dwarf_output object by copying using that
       collector (or, equivalently, call o.compile_units ().recollect (C)
       on the new collector C).  */
    class compile_units
      : public dwarf_data::compile_units<dwarf_output>
    {
      friend class dwarf_output;

    private:
      inline compile_units (const compile_units &)
	: dwarf_data::compile_units<dwarf_output> ()
      {
	never_copy ();
      }

      // Constructor copying CUs from input container.
      template<typename input, typename tracker>
      inline compile_units (const input &other, tracker &t)
	: dwarf_data::compile_units<dwarf_output> (other, t)
      {}

    public:
      // Default constructor: an empty container, no CUs.
      inline compile_units () {}
    };

  private:
    compile_units _m_units;

  public:
    class compile_units &compile_units ()
    {
      return _m_units;
    }
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  private:
    // Bind default copy-constructor and prevent it.
    inline dwarf_output (const dwarf_output &)
    {
      throw std::logic_error ("copying dwarf_output requires a collector");
    }

    // die offset -> file address
    typedef std::map< ::Dwarf_Off, ::Dwarf_Off> die_off_map;

    // [((pointer, length), die offset)]
    typedef std::vector<std::pair<std::pair<unsigned char *, size_t>,
				  ::Dwarf_Off> > backpatch_vec;
    static void recursively_dump (section_appender &appender,
				  dwarf_output_collector &c,
				  debug_info_entry const &die,
				  unsigned level,
				  bool a_addr_64,
				  die_off_map &die_off,
				  backpatch_vec &backpatch);

  public:
    // Constructor for an empty file, can add to its compile_units ().
    inline dwarf_output () {}

    // Constructor copying CUs from an input file (can be any of dwarf,
    // dwarf_edit, or dwarf_output).
    // Copy construction instantiates a copier derived from the collector.
    template<typename input>
    inline dwarf_output (const input &dw, dwarf_output_collector &c,
			 copier<input> maker = copier<input> ())
      : _m_units (dw.compile_units (), maker (c))
    {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }

    void output_debug_abbrev (section_appender &appender,
			      dwarf_output_collector &dw,
			      bool addr_64);

    void output_debug_info (section_appender &appender,
			    dwarf_output_collector &dw,
			    bool addr_64);
  };

  // Explicit specializations.
  template<>
  std::string to_string<dwarf_output::debug_info_entry>
  (const dwarf_output::debug_info_entry &);
  inline std::string dwarf_output::debug_info_entry::to_string () const
  {
    return elfutils::to_string (*this); // Use that.
  }
  template<>
  std::string
  to_string<dwarf_output::attribute> (const dwarf_output::attribute &);
  template<>
  std::string
  to_string<dwarf_output::attr_value> (const dwarf_output::attr_value &);

  inline std::string dwarf_output::attr_value::to_string () const
  {
    return elfutils::to_string (*this); // Use that.
  }

  class dwarf_output_collector
  {
    friend class dwarf_output;

  private:
    dwarf_path_finder<dwarf_output> _m_tracker;
    unsigned int _m_total;
    bool _m_output_built;

    typedef dwarf_output::debug_info_entry die_type;
    typedef die_type::attributes_type attrs_type;
    typedef die_type::children_type children_type;
    typedef children_type::const_iterator die_ptr;

    // Simple value sets for leaf types.
    subr::value_set<dwarf_output::value::value_string> _m_strings;
    subr::value_set<dwarf_output::value::value_identifier> _m_identifiers;
    subr::value_set<dwarf_output::value::value_address> _m_address;
    subr::value_set<dwarf_output::value::value_rangelistptr> _m_ranges;
    subr::value_set<dwarf_output::value::value_lineptr> _m_line_info;
    subr::value_set<dwarf_output::value::value_constant> _m_constants;
    subr::value_set<dwarf_output::value::value_constant_block> _m_const_block;
    subr::value_set<dwarf_output::value::value_dwarf_constant> _m_dwarf_const;
    subr::value_set<dwarf_output::value::value_source_file> _m_source_file;
    subr::value_set<dwarf_output::value::value_source_line> _m_source_line;
    subr::value_set<dwarf_output::value::value_source_column> _m_source_column;
    subr::value_set<dwarf_output::value::value_location> _m_locations;

    // The set of Boolean flags is a doubleton.
    static const dwarf_output::value::value_flag flag_true;
    static const dwarf_output::value::value_flag flag_false;
    static inline const dwarf_output::value::value_flag *flag (bool flag)
    {
      return flag ? &flag_true : &flag_false;
    }

    // Set of attribute maps.
    subr::identity_set<attrs_type> _m_attr_sets;

    template<typename input, typename copier_type>
    inline const attrs_type *add_attributes (const input &x, copier_type &c)
    {
      return &*_m_attr_sets.insert (attrs_type (x, c)).first;
    }

    // Set of children lists.
    //subr::identity_set<children_type> _m_broods;
    template<typename T>
    struct is2 : public std::equal_to<T *>
    {
      bool operator () (const T *a, const T *b) const
      {
	return a->is (*b);
      }
    };
    std::tr1::unordered_set<children_type *, children_type::hasher, is2<children_type> >
	_m_broods;

    template<typename input, typename copier_type>
    inline const children_type *add_children (const input &x, copier_type &c)
    {
      /* XXX another problem: We probably construct our references
	 from iterators pointing to the temporary vector.  When that
	 gets copied over to _m_broods, the original vector is
	 destroyed and iterators are left hanging there.  Work around
	 that by allocating on heap and bending a bunch of stuff to
	 work with pointers too.  Ugly & leaks, but works for now.  */
      return *_m_broods.insert (new children_type (x, c)).first;
    }

    struct die_info
    {
      unsigned int uses;
      bool with_sibling;
      bool without_sibling;

      size_t abbrev_code; // Or 0 if unassigned.

      inline die_info ()
	: uses (0), with_sibling (false), without_sibling (false)
	, abbrev_code (0)
      {}
    };

    // Set of unique DIEs.
    typedef subr::identity_map<die_type, die_info> die_map;
    die_map _m_unique;

    struct abbrev_attrib
    {
      unsigned name;
      unsigned form;

      bool operator< (abbrev_attrib const &other) const
      {
	return name < other.name
	  && form < other.form;
      }
    };

    typedef std::vector<die_type const *> die_ref_vect;

    struct shape_type
    {
      // name/form pairs.  Form is in fact a canonical form for given
      // form class, not actual form under which the data will be
      // emitted.
      typedef std::map<int, int> attrs_type;
      unsigned _m_tag;
      attrs_type _m_attrs;
      bool _m_has_children;
      size_t _m_hash;

      friend class subr::hashed_hasher<shape_type>;
      typedef subr::hashed_hasher<shape_type> hasher;

      shape_type (die_map::value_type const &emt);

      inline bool operator== (const shape_type &other) const
      {
	return (_m_hash == other._m_hash
		&& _m_tag == other._m_tag
		&& _m_has_children == other._m_has_children
		&& _m_attrs == other._m_attrs);
      }
      inline bool operator!= (const shape_type &other) const
      {
	return !(*this == other);
      }
    };

    inline const die_type *add_entry (die_type &die, bool has_sibling)
    {
      //std::cerr << "add_entry " << to_string (die) << " " << std::endl;
      die_map::value_type &x
	= *_m_unique.insert (std::make_pair (die, die_info ())).first;

      shape_type shape (x);
      shape_map::iterator st = _m_shapes.find (shape);
      if (st != _m_shapes.end ())
	st->second.add_user (&x.first);
      else
	_m_shapes.insert (std::make_pair (shape, shape_info (x)));

      x.second.uses++;
      ++_m_total;
      if (has_sibling)
	x.second.with_sibling = true;
      else
	x.second.without_sibling = true;

      return &x.first;
    }

    template<typename input, typename copier_type>
    inline const die_type *add_entry (const input &other, copier_type &c,
				      bool has_sibling)
    {
      die_type die (other, c);
      return add_entry (die, has_sibling);
    }

    struct shape_info
    {
      // We keep list of users of this shape.  That will make it
      // simpler to evaluate the space trade-offs when we generate
      // actual abbrevs from this shape.
      die_ref_vect _m_users;

      // Instances.  Instance is a sequence of concrete forms in the
      // order matching that of shape_type::_m_attrs.  Each shape can
      // produce several instances to ideally cover its users.  The
      // second element of the pair is unique code assigned to that
      // instance, or 0 if no code was assigned yet.
      // XXX is size_t enough?  Use uintptr_t?
      typedef std::pair<std::vector<int>, size_t> instance_type;
      typedef std::vector<instance_type> instances_type;
      instances_type _m_instances;

      // Maps users to their instances.
      typedef std::map<die_type const*, instances_type::const_iterator>
	  instance_map;
      instance_map _m_instance_map;

      shape_info (die_map::value_type const &emt)
      {
	add_user (&emt.first);
      }

      void add_user (die_type const *die)
      {
	_m_users.push_back (die);
      }

      void instantiate (shape_type const &shape);
      void build_data (shape_type const &shape,
		       instance_type const &inst,
		       section_appender &appender);
    };

    typedef std::tr1::unordered_map<shape_type, shape_info,
				    shape_type::hasher> shape_map;
    shape_map _m_shapes;

    void add_shape (die_type &die, bool last_sibling);

    void build_output ();

  public:
    inline dwarf_output_collector ()
      : _m_total (0)
      , _m_output_built (false)
    {}

    static void die_stats (const die_map::value_type &elt)
    {
      std::cout << to_string (elt.first) << " uses="
		<< std::dec << elt.second.uses
		<< " (" << elt.second.with_sibling
		<< "," << elt.second.without_sibling << ")\n";
    }

    void stats () const
    {
      std::cout << "collected " << std::dec << _m_unique.size ()
		<< " unique of " << _m_total << " total DIEs\n";
      std::for_each (_m_unique.begin (), _m_unique.end (), die_stats);
    }
  };

  template<typename dw>
  class dwarf_output::copier
    : public dwarf_ref_maker<dwarf_output, dw> // XXX temporary
  {
    friend class dwarf_output;
  private:

    struct tracker
      : public dwarf_ref_tracker<dwarf_output, dw>
    {
      typedef dwarf_ref_tracker<dwarf_output, dw> _base;

      inline tracker (const dwarf_output_collector &c)
	: _base (c._m_tracker)
      {}

      inline tracker (const tracker &proto,
		      typename _base::reference_match &matched,
		      const typename _base::left_context_type &lhs,
		      const typename _base::die1 &a,
		      const typename _base::right_context_type &rhs,
		      const typename _base::die2 &b)
	: _base (proto, matched, lhs, a, b)
      {}

    };

    dwarf_output_collector *_m_collector;
    tracker *_m_tracker;

    inline copier ()
      : _m_collector (NULL), _m_tracker (NULL)
    {}

    inline ~copier ()
    {
      if (_m_tracker != NULL)
	delete _m_tracker;
    }

    copier &operator () (dwarf_output_collector &c)
    {
      _m_collector = &c;
      assert (_m_tracker == NULL);
      _m_tracker = new tracker (c);
      return *this;
    }

    inline operator dwarf_output_collector & ()
    {
      return *_m_collector;
    }

    template<typename input>
    inline const value::value_string *add_string (const input &x)
    {
      return _m_collector->_m_strings.add (x);
    }

    template<typename input>
    inline const value::value_string *add_identifier (const input &x)
    {
      return _m_collector->_m_identifiers.add (x);
    }

    template<typename input>
    inline const value::value_reference *add_reference (const input &x)
    {
      // XXX temporary kludge (leak!)
      return new value::value_reference (x, *this);
    }

    template<typename input>
    inline const value::value_flag *add_flag (const input &x)
    {
      return dwarf_output_collector::flag (x);
    }

    template<typename input>
    inline const value::value_address *add_address (const input &x)
    {
      return _m_collector->_m_address.add (x);
    }

    template<typename input>
    inline const value::value_rangelistptr *add_ranges (const input &x)
    {
      return _m_collector->_m_ranges.add (x);
    }

    template<typename input>
    inline const value::value_lineptr *add_line_info (const input &x)
    {
      return _m_collector->_m_line_info.add (x, *_m_collector);
    }

    template<typename input>
    inline const value::value_constant *add_constant (const input &x)
    {
      return _m_collector->_m_constants.add (x);
    }

    template<typename input>
    inline const value::value_constant_block *
    add_constant_block (const input &x)
    {
      return _m_collector->_m_const_block.add (x);
    }

    template<typename input>
    inline const value::value_dwarf_constant *
    add_dwarf_constant (const input &x)
    {
      return _m_collector->_m_dwarf_const.add (x);
    }

    template<typename input>
    inline const value::value_source_file *add_source_file (int /*whatattr*/,
							    const input &x)
    {
      return _m_collector->_m_source_file.add (x);
    }

    template<typename input>
    inline const value::value_source_line *add_source_line (const input &x)
    {
      return _m_collector->_m_source_line.add (x);
    }

    template<typename input>
    inline const value::value_source_column *add_source_column (const input &x)
    {
      return _m_collector->_m_source_column.add (x);
    }

    template<typename input>
    inline const value::value_location *add_location (const input &x)
    {
      return _m_collector->_m_locations.add (x);
    }

    template<typename input>
    inline const debug_info_entry::attributes_type *
    add_attributes (const input &x)
    {
      return _m_collector->add_attributes (x, *this);
    }

    template<typename input>
    inline const debug_info_entry::children_type *
    add_children (const input &x)
    {
      return _m_collector->add_children (x, *this);
    }

    template<typename input>
    inline const debug_info_entry *
    add_entry (const input &x, bool has_sibling)
    {
      return _m_collector->add_entry (x, *this, has_sibling);
    }

    const debug_info_entry *add_entry_2 (debug_info_entry &x, bool has_sibling)
    {
      return _m_collector->add_entry (x, has_sibling);
    }

    template<typename input_iter>
    inline void copied (const debug_info_entry::children_type::iterator &out,
			const input_iter &in, bool /*has_sibling*/)
    {
      equivalence (out, in);
      // XXX _m_collector->add_shape (*out, !has_sibling);
    }
  };
};

#endif	// <elfutils/dwarf_output>
