/* elfutils::dwarf_output -- DWARF file generation in -*- C++ -*-
   Copyright (C) 2009 Red Hat, Inc.
   This file is part of Red Hat elfutils.

   Red Hat elfutils is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by the
   Free Software Foundation; version 2 of the License.

   Red Hat elfutils is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with Red Hat elfutils; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301 USA.

   In addition, as a special exception, Red Hat, Inc. gives You the
   additional right to link the code of Red Hat elfutils with code licensed
   under any Open Source Initiative certified open source license
   (http://www.opensource.org/licenses/index.php) which requires the
   distribution of source code with any binary distribution and to
   distribute linked combinations of the two.  Non-GPL Code permitted under
   this exception must only link to the code of Red Hat elfutils through
   those well defined interfaces identified in the file named EXCEPTION
   found in the source code files (the "Approved Interfaces").  The files
   of Non-GPL Code may instantiate templates or use macros or inline
   functions from the Approved Interfaces without causing the resulting
   work to be covered by the GNU General Public License.  Only Red Hat,
   Inc. may make changes or additions to the list of Approved Interfaces.
   Red Hat's grant of this exception is conditioned upon your not adding
   any new exceptions.  If you wish to add a new Approved Interface or
   exception, please contact Red Hat.  You must obey the GNU General Public
   License in all respects for all of the Red Hat elfutils code and other
   code used in conjunction with Red Hat elfutils except the Non-GPL Code
   covered by this exception.  If you modify this file, you may extend this
   exception to your version of the file, but you are not obligated to do
   so.  If you do not wish to provide this exception without modification,
   you must delete this exception statement from your version and license
   this file solely under the GPL without exception.

   Red Hat elfutils is an included package of the Open Invention Network.
   An included package of the Open Invention Network is a package for which
   Open Invention Network licensees cross-license their patents.  No patent
   license is granted, either expressly or impliedly, by designation as an
   included package.  Should you wish to participate in the Open Invention
   Network licensing program, please visit www.openinventionnetwork.com
   <http://www.openinventionnetwork.com>.  */

#ifndef _ELFUTILS_DWARF_OUTPUT
#define _ELFUTILS_DWARF_OUTPUT	1

#include "dwarf"

/* Read the comments for elfutils::dwarf first.

   The elfutils::dwarf_output class is template-compatible with the logical
   containers described in elfutils::dwarf and elfutils::dwarf_edit.

   The dwarf_output representation of the DWARF data is immutable once
   created.  The only way to create the object is by copy-construction
   from another compatible object: dwarf, dwarf_edit, or dwarf_output.
   Construction collects all the information necessary to generate the
   formatted DWARF sections.  */

namespace elfutils
{
  class dwarf_output
  {
    dwarf_edit _m_debug;

  public:
    class compile_unit;
    class compile_units;
    class debug_info_entry;

    class debug_info_entry
    {
    public:

      class children : public std::vector<debug_info_entry>
      {
	friend class debug_info_entry;
	friend class compile_unit;
      private:
        children () {}

	template<typename childrens>
	children (const childrens &other)
	  : std::vector<debug_info_entry> (other.begin (), other.end ()) {}
      };

      class attributes;

    private:
      // xxx should be const, but this is placed into vector, and
      // vector moves its elements around with assignment operator in
      // case the capacity is reached.
      int _m_tag;
      attributes *_m_attributes;
      children _m_children;

    protected:
      debug_info_entry (int t, const attributes &attr, const children &c)
	: _m_tag (t),
	  _m_attributes (NULL /*attr*/), // xxx yyy
	  _m_children (c)
      {}

    public:
      /* The template constructor lets us copy in from any class that has
	 compatibly iterable containers for attributes and children.  */
      template<typename die>
      debug_info_entry (const die &die)
	: _m_tag (die.tag ()),
	  _m_attributes (NULL /*die.attributes ()*/), // xxx yyy
	  _m_children (die.children ())
      {}

      inline int tag () const
      {
	return _m_tag;
      }

      inline bool has_children () const
      {
	return !_m_children.empty ();
      }

      inline const class children &children () const
      {
	return _m_children;
      }

      inline const class attributes &attributes () const
      {
	return *_m_attributes;
      }

      template<typename die>
      bool operator== (const die &other) const
      {
	return (other.attributes () == attributes ()
		&& other.children () == children ());
      }
      template<typename die>
      bool operator!= (const die &other) const
      {
	return !(*this == other);
      }

      // xxx
      inline ::Dwarf_Off identity () const { return (uintptr_t) this; }
      inline ::Dwarf_Off offset () const { return identity (); }
    };

    // xxx
    // Same as set<pair<Dwarf_Addr, Dwarf_Addr>>.
    class range_list : public dwarf::arange_list
    {
    public:
      range_list () {} // xxx drop?
      template<typename list>
      range_list (const list &other)
	: dwarf::arange_list (other.begin (), other.end ()) {}
    };

    class source_file
    {
    public:
      // xxx
      template <typename table>
      bool operator == (const table &other) { return false; }
      inline ::Dwarf_Word mtime () const { return 0; } // xxx
      inline ::Dwarf_Word size () const { return 0; } // xxx
      inline std::string name () const { return ""; } // xxx
    };

    class line_entry
    {
    public:
      inline source_file file () const { return source_file (); } // xxx
      bool epilogue_begin () const { return false; } // xxx
      bool prologue_end () const { return false; } // xxx
      bool end_sequence () const { return false; } // xxx
      bool basic_block () const { return false; } // xxx
      bool statement () const { return false; } // xxx
      unsigned int line () const { return 0; } // xxx
      unsigned int column () const { return 0; } // xxx
      ::Dwarf_Addr address () const { return 0; } // xxx
    };

    class line_table
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef line_entry value_type;

      typedef subr::indexed_iterator<line_table> const_iterator;

      inline bool empty () const { return true; } // xxx
      size_t size () const { return 0; } // xxx

      inline const_iterator begin () const
      {
	return const_iterator (*this, 0);
      }
      inline const_iterator end () const
      {
	return const_iterator (*this, size ());
      }

      const line_entry at (size_t idx) const { return line_entry (); } // xxx

      const line_entry operator[] (size_t idx) const
      {
	return at (idx);
      }

      template<typename table>
      inline bool operator== (const table &other) const
      {
	return size () == other.size () && subr::container_equal (*this, other);
      }
      template<typename table>
      inline bool operator!= (const table &other) const
      {
	return !(*this == other);
      }

      // Look up by matching address.
      const_iterator find (::Dwarf_Addr) const { return begin (); } // xxx
    };

    class line_info_table
    {
    public:
      // xxx
      template <typename table>
      bool operator == (const table &other) { return false; }
      line_table lines () const { return line_table (); } // xxx
      std::vector<std::string> include_directories () const { return std::vector<std::string> (); } // xxx
    };

    class location_attr : public std::map<dwarf::location_attr::key_type,
					  std::vector<uint8_t> >
    {
    private:
      typedef std::map<dwarf::location_attr::key_type,
		       std::vector<uint8_t> > _base;

    public:
      // xxx
      template <typename table>
      bool operator == (const table &other) const { return false; } // xxx
      bool empty () const { return false; } // xxx
      bool is_list () const { return false; } // xxx
      inline mapped_type location () const { return mapped_type (); } // xxx
    };

    // XXX later
    class attr_value
    {
    public:
      template <typename value>
      attr_value (const value &val)
      {
	// xxx
      }

      dwarf::value_space what_space () const
      {
	// xxx
	return dwarf::VS_location;
      }

      // Return an iterator on which * will yield the referent debug_info_entry.
      inline debug_info_entry::children::const_iterator reference () const {
	// xxx
	return debug_info_entry::children::const_iterator (NULL);
      }
      inline bool flag () const {
	// xxx
	return false;
      }
      inline range_list ranges () const {
	// xxx
	// xxx return const&?
	return range_list ();
      }
      inline line_info_table line_info () const {
	// xxx
	// xxx return const&?
	return line_info_table ();
      }
      inline ::Dwarf_Word constant () const {
	// xxx
	return 0;
      }
      inline ::Dwarf_Word dwarf_constant () const {
	// xxx
	return 0;
      }
      inline bool constant_is_integer () const {
	// xxx
	return false;
      }
      inline std::vector<uint8_t> constant_block () const {
	// xxx
	// xxx return const&?
	return std::vector<uint8_t> ();
      }
      inline unsigned int source_line () const {
	// xxx
	return 0;
      }
      inline unsigned int source_column () const {
	// xxx
	return 0;
      }
      inline std::string identifier () const {
	// xxx
	// xxx return const&?
	return "";
      }
      inline std::string string () const {
	// xxx
	// xxx return const&?
	return "";
      }
      inline ::Dwarf_Addr address () const {
	// xxx
	// xxx return const&?
	return 0;
      }
      inline dwarf_output::source_file source_file () const {
	// xxx
	return dwarf_output::source_file ();
      }
      inline location_attr location () const {
	// xxx
	return location_attr ();
      }
    };

    class debug_info_entry::attributes
      : public std::map<int, attr_value>
    {
      friend class debug_info_entry;
      friend class compile_unit;
    private:
      attributes () {}

      template<typename attrs>
      attributes (const attrs &other)
	: std::map<int, attr_value> (other.begin (), other.end ()) {}

    public:
      template<typename attrs>
      inline operator attrs () const
      {
	return attrs (begin (), end ());
      }

      static const bool ordered = true; // xxx?
    };

    typedef debug_info_entry::attributes::value_type attribute;

    class compile_unit : public debug_info_entry
    {
    public:
      // xxx
      template <typename input>
      compile_unit(const input &unit)
	: debug_info_entry (unit.tag (),
			    unit.attributes (),
			    unit.children ())
      {
      }
    };

    // Main container anchoring all the output.
    class compile_units : public std::vector<compile_unit>
    {
      friend class dwarf_output;
    private:
      // Constructor copying CUs from input container.
      template<typename input>
      compile_units(const input &units)
	: std::vector<compile_unit> (units.begin (), units.end ())
      {}

    public:
      template<typename other_children>
      bool operator== (const other_children &other) const
      {
	return std::equal (begin (), end (), other.begin ());
      }
      template<typename other_children>
      bool operator!= (const other_children &other) const
      {
	return !(*this == other);
      }
    };

  private:
    const compile_units _m_units;

  public:
    const class compile_units &compile_units () const
    {
      return _m_units;
    }

  public:
    // Constructor copying CUs from an input file (dwarf or dwarf_output).
    template<typename input>
    dwarf_output (const input &dw) : _m_units (dw.compile_units ()) {}

    template<typename file>
    inline bool operator== (const file &other) const
    {
      return compile_units () == other.compile_units ();
    }
    template<typename file>
    inline bool operator!= (const file &other) const
    {
      return !(*this == other);
    }
  };

  template<>
  std::string to_string<dwarf_output::attribute> (const dwarf_output::attribute &)
  {
    return ""; //xxx
  }
}

#endif	// <elfutils/dwarf_output>
